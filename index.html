<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wheel v3 Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./styles/base.css" />
    <link id="volume-style" rel="stylesheet" href="" />
</head>
<body>
  <div id="version-badge" class="version-badge" aria-label="Application version"></div>
  <svg id="app" aria-label="Wheel v3"></svg>
  <script type="module">
    import { createApp, getViewportInfo, buildBibleVerseCousinChain, buildBibleBookCousinChain } from './src/index.js';

    const svg = document.getElementById('app');
    const viewport = getViewportInfo(window.innerWidth, window.innerHeight);

    async function loadConfig() {
      const params = new URLSearchParams(window.location.search);
      const path = (window.location.pathname || '').toLowerCase();
      const paramVolume = params.get('volume');
      const pathVolume = path.includes('/catalog')
        ? 'catalog'
        : path.includes('/calendar')
          ? 'calendar'
          : path.includes('/bible')
            ? 'bible'
            : null;
      const volume = ['catalog', 'calendar', 'bible'].includes(paramVolume)
        ? paramVolume
        : pathVolume || 'bible';

      const manifestPath = volume === 'catalog'
        ? './data/mmdm/mmdm_catalog.json'
        : volume === 'calendar'
          ? './data/calendar/manifest.json'
          : './data/gutenberg/manifest.json';

      console.info('[wheel-v3] volume selection', {
        pathname: path,
        paramVolume,
        pathVolume,
        resolvedVolume: volume,
        manifestPath
      });

      const manifest = await fetch(manifestPath).then(r => r.json());
      const translationsMeta = volume === 'bible'
        ? await fetch('./data/gutenberg/translations.json').then(r => r.json()).catch(() => null)
        : null;
      const volumeRoot = volume === 'catalog' ? manifest?.MMdM : volume === 'calendar' ? manifest?.Calendar : manifest?.Gutenberg_Bible;
      const startup = volumeRoot?.display_config?.focus_ring_startup || {};
      const arrangements = volumeRoot?.display_config?.focus_ring_arrangements || {};
      const locale = params.get('lang') || 'english';
      const level = params.get('level')
        || startup.top_navigation_level
        || (volume === 'bible' ? 'book' : volume === 'calendar' ? 'year' : 'manufacturer');
      const initialItemId = params.get('item') || startup.initial_magnified_item || null;
      const arrangement = params.get('arrangement')
        || arrangements[level]
        || startup.arrangement
        || (volume === 'bible' ? 'cousins-with-gaps' : volume === 'calendar' ? 'cousins-with-gaps' : 'cousins-flat');
      const cousinParam = params.get('cousins');
      const cousinMode = cousinParam === null
        ? arrangement !== 'siblings-only'
        : cousinParam === '1';
      const dimensionEnabled = params.get('dimension') === '1';
      return {
        volume,
        manifest,
        translationsMeta,
        options: {
          level,
          initialItemId,
          arrangement,
          bookId: params.get('book') || 'GENE',
          testamentId: params.get('testament'),
          chapterId: params.get('chapter'),
          translation: params.get('translation') || 'NAB',
          cousinMode,
          locale,
          dimensionEnabled
        }
      };
    }

    function applyTheme(manifest, volume) {
      const root = document.documentElement;
      const theme = volume === 'catalog' ? 'catalog' : volume === 'calendar' ? 'calendar' : 'bible';
      root.setAttribute('data-theme', theme);
        const link = document.getElementById('volume-style');
        if (link) {
          link.setAttribute('href', `./styles/${theme}.css`);
        }
    }

    function makeLabelFormatter({ volume, level, locale }) {
      const translations = {
        english: {
          chapter: 'Chapter',
          verse: 'Verse',
          bc: 'B.C.',
          ad: 'A.D.'
        }
      };
      const t = key => translations[locale]?.[key] || translations.english[key] || key;

      const getYearNumber = item => {
        if (Number.isFinite(item?.yearNumber)) return item.yearNumber;
        const parsed = Number.parseInt(item?.id, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };

      const formatYear = ({ item, context }) => {
        const yearNumber = getYearNumber(item);
        if (!Number.isFinite(yearNumber)) return item?.name || item?.id || '';
        if (context === 'node') return String(Math.abs(yearNumber));
        const era = yearNumber < 0 ? t('bc') : t('ad');
        return `${Math.abs(yearNumber)} ${era}`;
      };

      const formatChapter = ({ item, context }) => {
        const chapterVal = item?.chapter ?? (() => {
          const asNumber = Number.parseInt(item?.name, 10);
          if (Number.isFinite(asNumber)) return asNumber;
          return item?.name;
        })();
        if (context === 'node') return String(chapterVal ?? item?.id ?? '');
        return `${t('chapter')} ${chapterVal ?? item?.id ?? ''}`.trim();
      };

      const formatVerse = ({ item, context }) => {
        const extract = () => {
          if (item?.verse !== undefined) return item.verse;
          if (typeof item?.name === 'string' && item.name.includes(':')) {
            const parts = item.name.split(':');
            return parts[parts.length - 1];
          }
          return item?.name;
        };
        const verseVal = extract();
        if (context === 'node') return String(verseVal ?? item?.id ?? '');
        return `${t('verse')} ${verseVal ?? item?.id ?? ''}`.trim();
      };

      return ({ item, context }) => {
        if (!item) return '';
        if (volume === 'calendar') return formatYear({ item, context });
        if (volume === 'bible') {
          if (level === 'chapter') return formatChapter({ item, context });
          if (level === 'verse') return formatVerse({ item, context });
          return item.name || item.id || '';
        }
        return item.name || item.id || '';
      };
    }

    function buildBibleBooks(manifest) {
      const testaments = manifest?.Gutenberg_Bible?.testaments;
      if (!testaments) return [];
      const items = [];
      Object.entries(testaments).forEach(([testamentId, testament]) => {
        const sections = testament?.sections || {};
        Object.entries(sections).forEach(([sectionId, section]) => {
          const books = section?.books || {};
          Object.entries(books).forEach(([bookId, book]) => {
            items.push({
              id: bookId,
              name: book?.book_name || book?.name || bookId,
              sort: book?.sort_number || items.length + 1
            });
          });
        });
      });
      return items;
    }

    function buildCatalogManufacturers(manifest, { initialItemId } = {}) {
      const markets = manifest?.MMdM?.markets;
      if (!markets) return { items: [], selectedIndex: 0, preserveOrder: false };
      const items = [];
      const target = initialItemId ? String(initialItemId).toLowerCase() : null;
      Object.entries(markets).forEach(([marketId, market]) => {
        const countries = market?.countries || {};
        Object.entries(countries).forEach(([countryId, country]) => {
          const manufacturers = country?.manufacturers || {};
          Object.entries(manufacturers).forEach(([manufacturerId, manufacturer]) => {
            items.push({
              id: `${marketId}__${countryId}__${manufacturerId}`,
              name: manufacturerId,
              sort: Number.isFinite(manufacturer?.sort_number) ? manufacturer.sort_number : items.length + 1
            });
          });
        });
      });

      items.sort((a, b) => {
        const as = a.sort || 0;
        const bs = b.sort || 0;
        if (as === bs) return (a.name || '').localeCompare(b.name || '');
        return as - bs;
      });
      items.forEach((item, idx) => { item.order = idx; });

      const selectedIndex = (() => {
        if (target) {
          const idx = items.findIndex(item => {
            const simple = String(item.name || '').toLowerCase();
            return simple === target || String(item.id || '').toLowerCase() === target;
          });
          if (idx >= 0) return idx;
        }
        return 0;
      })();

      return { items, selectedIndex, preserveOrder: false };
    }

    function buildCalendarYears(manifest, { arrangement, initialItemId } = {}) {
      const years = manifest?.Calendar?.years;
      if (!years) return { items: [], selectedIndex: 0, preserveOrder: true };
      const sortedYears = Object.values(years)
        .map(year => {
          const yearNumber = Number.isFinite(year?.year_number) ? year.year_number : parseInt(year?.id, 10);
          const name = year?.name || (Number.isFinite(yearNumber) ? (yearNumber < 0 ? `${Math.abs(yearNumber)} BC` : `${yearNumber} AD`) : String(year?.id || ''));
          const sort = Number.isFinite(year?.sort_number) ? year.sort_number : yearNumber || 0;
          return {
            id: year?.id || String(yearNumber),
            name,
            sort,
            yearNumber
          };
        })
        .sort((a, b) => (a.sort || 0) - (b.sort || 0));

      const chain = [];
      let currentMillennium = null;
      sortedYears.forEach(year => {
        const millennium = year.yearNumber > 0
          ? Math.floor((year.yearNumber - 1) / 1000)
          : Math.floor((year.yearNumber) / 1000) - 1; // keep negative blocks distinct
        const shouldGap = (arrangement || 'cousins-with-gaps') === 'cousins-with-gaps';
        if (shouldGap && currentMillennium !== null && millennium !== currentMillennium) {
          chain.push(null, null); // 2-node gap between millennia
        }
        currentMillennium = millennium;
        chain.push({
          ...year,
          order: chain.length
        });
      });

      const selectedIndex = (() => {
        if (initialItemId !== undefined && initialItemId !== null) {
          const match = chain.findIndex(item => item && (item.id === String(initialItemId) || String(item.yearNumber) === String(initialItemId) || item.name === String(initialItemId)));
          if (match >= 0) return match;
        }
        const firstReal = chain.findIndex(item => item !== null);
        return firstReal >= 0 ? firstReal : 0;
      })();
      return {
        items: chain,
        selectedIndex,
        preserveOrder: true
      };
    }

    async function buildChain(manifest, volume, options = {}) {
      const arrangement = options.arrangement;
      const initialItemId = options.initialItemId;
      if (volume === 'bible' && options.cousinMode && (arrangement || 'cousins-with-gaps') !== 'siblings-only') {
        const level = options.level || 'book';
        if (level === 'verse') {
          return buildBibleVerseCousinChain(manifest, {
            bookId: options.bookId || 'GENE',
            startChapterId: options.chapterId || undefined,
            translation: options.translation || 'NAB'
          });
        }
        return buildBibleBookCousinChain(manifest, {
          testamentId: options.testamentId,
          bookId: options.bookId || 'GENE',
          initialItemId
        });
      }
      if (volume === 'catalog') {
        return buildCatalogManufacturers(manifest, { initialItemId });
      }
      if (volume === 'calendar') {
        return buildCalendarYears(manifest, { arrangement, initialItemId });
      }
      const items = buildBibleBooks(manifest)
        .sort((a, b) => {
          const as = a.sort || 0;
          const bs = b.sort || 0;
          if (as === bs) return (a.name || '').localeCompare(b.name || '');
          return as - bs;
        })
        .map((item, idx) => ({ ...item, order: idx }));
      const selectedIndex = (() => {
        if (initialItemId) {
          const idx = items.findIndex(item => item && (item.id === initialItemId));
          if (idx >= 0) return idx;
        }
        return 0;
      })();
      return { items, selectedIndex, preserveOrder: false };
    }

    function wireInteractions(app, itemCount) {
      let isDragging = false;
      let isSecondaryDragging = false;
      let lastX = 0;
      let lastY = 0;
      let lastTime = 0;
      const isInteractionLocked = () => Boolean(app?.isBlurred?.());
      const hasSecondary = () => Boolean(app?.hasSecondary?.());
      const sensitivity = Math.PI / 4 / 100; // 100px → 45°
      const velocityThreshold = 0.4; // px/ms below this → no gain
      const gainSlope = 1.1; // linear slope past threshold
      const baseQuickNodes = 60; // empirical baseline nodes per quick swipe at gain 1
      const targetSpinNodes = 350; // fixed quick-flick span for consistency across devices
      const baseMaxGain = Math.max(1, targetSpinNodes / baseQuickNodes);

      const onPointerMove = event => {
        if (!isDragging && !isSecondaryDragging) return;
        if (isInteractionLocked() && !isSecondaryDragging) {
          isDragging = false;
          return;
        }
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        const dt = event.timeStamp - lastTime;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;

        const distance = Math.abs(dx) + Math.abs(dy);
        const velocity = dt > 0 ? distance / dt : 0;
        const maxGain = baseMaxGain;
        const gain = velocity <= velocityThreshold
          ? 1
          : Math.min(maxGain, 1 + (velocity - velocityThreshold) * gainSlope);

        const delta = -(dx + dy) * sensitivity * gain;
        if (isSecondaryDragging) {
          app.rotateSecondary(delta);
        } else {
          app.choreographer.rotate(delta);
        }
      };

      svg.addEventListener('pointerdown', event => {
        const blurred = isInteractionLocked();
        if (blurred && hasSecondary()) {
          isSecondaryDragging = true;
          isDragging = false;
          lastX = event.clientX;
          lastY = event.clientY;
          lastTime = event.timeStamp;
          app.beginSecondaryRotation();
          return;
        }
        if (blurred) {
          isDragging = false;
          app.choreographer.stopMomentum();
          return;
        }
        const isNode = event.target && event.target.closest && event.target.closest('.focus-ring-node');
        if (isNode) {
          return; // click handler on node will manage rotation
        }
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;
      });

      svg.addEventListener('pointermove', onPointerMove);

      ['pointerup', 'pointercancel', 'pointerleave'].forEach(type => {
        svg.addEventListener(type, () => {
          if (isSecondaryDragging) {
            isSecondaryDragging = false;
            if (app.endSecondaryRotation) app.endSecondaryRotation();
            return;
          }
          isDragging = false;
          if (isInteractionLocked()) return;
          app.selectNearest();
          app.choreographer.stopMomentum();
        });
      });
    }

    async function showVersion() {
      const badge = document.getElementById('version-badge');
      if (!badge) return;
      try {
        const pkg = await fetch('./package.json').then(r => r.json());
        const name = pkg?.name || 'wheel';
        const version = pkg?.version ? `v${pkg.version}` : 'v?';
        badge.textContent = `${name} ${version}`;
      } catch (err) {
        console.warn('Version load failed', err);
        badge.textContent = 'version unavailable';
      }
    }

    const translationsForLanguage = (translationsMeta, language) => {
      const translations = translationsMeta?.translations || {};
      const entries = Object.entries(translations)
        .filter(([, t]) => t?.language === language);
      if (!entries.length) return null;
      const both = entries.find(([, t]) => (t?.testament || '').toLowerCase() === 'both');
      if (both) return both[0];
      return entries[0][0];
    };

    const buildSecondaryLanguages = (translationsMeta, currentTranslation) => {
      const nativeNames = {
        latin: 'Latina',
        greek: 'Ελληνικά',
        hebrew: 'עברית',
        english: 'English',
        french: 'Français',
        spanish: 'Español',
        italian: 'Italiano',
        portuguese: 'Português',
        russian: 'Русский'
      };
      const desiredOrder = ['hebrew', 'greek', 'latin', 'french', 'spanish', 'english', 'italian', 'portuguese', 'russian'];
      const normalize = lang => (lang || '').toLowerCase().trim() === 'portugese' ? 'portuguese' : (lang || '').toLowerCase().trim();
      const translations = translationsMeta?.translations || {};
      const items = desiredOrder.map((lang, idx) => {
        const normalizedLang = normalize(lang);
        const translation = translationsForLanguage(translationsMeta, normalizedLang) || currentTranslation || 'NAB';
        const name = nativeNames[normalizedLang]
          || (translations[translation]?.language_name)
          || (normalizedLang ? `${normalizedLang.charAt(0).toUpperCase()}${normalizedLang.slice(1)}` : 'Language');
        return {
          id: normalizedLang,
          name,
          order: idx,
          translation
        };
      });
      const currentLang = translations?.[currentTranslation]?.language;
      const selectedIndex = (() => {
        if (currentLang) {
          const idx = items.findIndex(item => item.id === currentLang);
          if (idx >= 0) return idx;
        }
        return 0;
      })();
      return { items, selectedIndex };
    };

    loadConfig().then(async ({ volume, manifest, translationsMeta, options }) => {
      applyTheme(manifest, volume);
      const { items, selectedIndex = 0, preserveOrder = false } = await buildChain(manifest, volume, options);
      const secondary = volume === 'bible' ? buildSecondaryLanguages(translationsMeta, options.translation) : { items: [], selectedIndex: 0 };
      if (!items.length) {
        console.error('No items found for volume', volume);
        return;
      }
      const labelFormatter = makeLabelFormatter({ volume, level: options.level, locale: options.locale || 'english' });
      const shouldCenterLabel = ({ item }) => volume === 'calendar';
      const app = createApp({
        svgRoot: svg,
        items,
        viewport,
        selectedIndex,
        preserveOrder,
        labelFormatter,
        shouldCenterLabel,
        secondaryItems: secondary.items,
        secondarySelectedIndex: secondary.selectedIndex,
        onSelectSecondary: translationId => {
          const url = new URL(window.location.href);
          url.searchParams.set('translation', translationId);
          url.searchParams.set('dimension', '1');
          window.location.href = url.toString();
        }
      });
      if (options.dimensionEnabled && app?.setBlur) {
        app.setBlur(true);
      }
      wireInteractions(app, items.length);
      showVersion();
    }).catch(err => {
      console.error('Failed to initialize app', err);
    });
  </script>
</body>
</html>
