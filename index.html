<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wheel v3 Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./styles/base.css" />
  <link id="volume-style" rel="stylesheet" href="" />
  <link rel="icon" href="data:," />
</head>
<body>
  <div id="version-badge" class="version-badge" aria-label="Application version"></div>
  <svg id="app" aria-label="Wheel v3"></svg>
  <div id="detail-panel" class="detail-panel" aria-label="Detail panel">
    <div id="detail-content" class="detail-content"></div>
  </div>
  <script type="module">
    import { createApp, getViewportInfo, buildBibleVerseCousinChain, buildBibleBookCousinChain, validateVolumeRoot } from './src/index.js';
    import { getPlacesLevels, buildPlacesLevel, buildCalendarYears, buildBibleBooks, buildCatalogManufacturers, getCatalogChildren, getCalendarMonths, getBibleChapters } from './src/adapters/volume-helpers.js';
    import { createVolumeLayoutSpec } from './src/adapters/volume-layout.js';
    import { createAdapterRegistry, createAdapterLoader } from './src/adapters/registry.js';
    import { catalogAdapter } from './src/adapters/catalog-adapter.js';
    import { bibleAdapter } from './src/adapters/bible-adapter.js';
    import { calendarAdapter } from './src/adapters/calendar-adapter.js';
    import { placesAdapter } from './src/adapters/places-adapter.js';
    import { DetailPluginRegistry } from './src/view/detail/plugin-registry.js';
    import { TextDetailPlugin } from './src/view/detail/plugins/text-plugin.js';
    import { CardDetailPlugin } from './src/view/detail/plugins/card-plugin.js';

    const svg = document.getElementById('app');
    const viewport = getViewportInfo(window.innerWidth, window.innerHeight);
    const adapterRegistry = createAdapterRegistry();
    adapterRegistry.register('catalog', () => ({ ...catalogAdapter, volumeId: 'catalog' }));
    adapterRegistry.register('bible', () => ({ ...bibleAdapter, volumeId: 'bible' }));
    adapterRegistry.register('calendar', () => ({ ...calendarAdapter, volumeId: 'calendar' }));
    adapterRegistry.register('places', () => ({ ...placesAdapter, volumeId: 'places' }));
    const adapterLoader = createAdapterLoader(adapterRegistry);

    const DEFAULT_VOLUME = 'bible';
    const volumeConfigs = {
      bible: {
        id: 'bible',
        paths: ['/bible'],
        manifestPath: './data/gutenberg/manifest.json',
        theme: 'bible',
        extractRoot: manifest => manifest?.Gutenberg_Bible,
        async loadSupplemental() {
          const translationsMeta = await fetch('./data/gutenberg/translations.json').then(r => r.json()).catch(() => null);
          return { translationsMeta };
        },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || 'book';
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-with-gaps';
          const cousinParam = params.get('cousins');
          const cousinMode = cousinParam === null ? arrangement !== 'siblings-only' : cousinParam === '1';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            bookId: params.get('book') || 'GENE',
            testamentId: params.get('testament'),
            chapterId: params.get('chapter'),
            translation: params.get('translation') || 'NAB',
            cousinMode,
            locale: params.get('lang') || null,
            dimensionEnabled: params.get('dimension') === '1'
          };
        },
        formatLabel: ({ level, locale, namesMap }) => makeBibleLabelFormatter({ level, locale, namesMap }),
        buildChain: (manifest, options, namesMap) => buildBibleChain(manifest, options, namesMap),
        createHandlers: params => {
          const adapter = adapterLoader.load('bible');
          return adapter?.createHandlers ? adapter.createHandlers(params) : { parentHandler: () => false, childrenHandler: () => false, secondary: { items: [], selectedIndex: 0 }, layoutBindings: {} };
        }
      },
      catalog: {
        id: 'catalog',
        paths: ['/catalog'],
        manifestPath: './data/mmdm/mmdm_catalog.json',
        theme: 'catalog',
        extractRoot: manifest => manifest?.MMdM,
        async loadSupplemental() { return { translationsMeta: null }; },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || 'manufacturer';
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-flat';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            locale: params.get('lang') || null,
            cousinMode: arrangement !== 'siblings-only'
          };
        },
        formatLabel: () => ({ item }) => item?.name || item?.id || '',
        buildChain: (manifest, options) => buildCatalogManufacturers(manifest, { initialItemId: options.initialItemId }),
        createHandlers: params => {
          const adapter = adapterLoader.load('catalog');
          return adapter?.createHandlers ? adapter.createHandlers(params) : { parentHandler: () => false, childrenHandler: () => false, layoutBindings: {} };
        }
      },
      calendar: {
        id: 'calendar',
        paths: ['/calendar'],
        manifestPath: './data/calendar/manifest.json',
        theme: 'calendar',
        centerLabel: true,
        extractRoot: manifest => manifest?.Calendar,
        async loadSupplemental() { return { translationsMeta: null }; },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || 'year';
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-with-gaps';
          const cousinParam = params.get('cousins');
          const cousinMode = cousinParam === null ? arrangement !== 'siblings-only' : cousinParam === '1';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            locale: params.get('lang') || null,
            cousinMode
          };
        },
        formatLabel: ({ locale }) => makeCalendarLabelFormatter({ locale }),
        buildChain: (manifest, options) => buildCalendarYears(manifest, { arrangement: options.arrangement, initialItemId: options.initialItemId }),
        createHandlers: params => {
          const adapter = adapterLoader.load('calendar');
          return adapter?.createHandlers ? adapter.createHandlers(params) : { parentHandler: () => false, childrenHandler: () => false, layoutBindings: {} };
        }
      },
      places: {
        id: 'places',
        paths: ['/places'],
        manifestPath: './data/places/manifest.json',
        theme: 'places',
        extractRoot: manifest => manifest?.Places,
        async loadSupplemental() { return { translationsMeta: null }; },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || null;
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-flat';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            locale: params.get('lang') || null,
            cousinMode: arrangement !== 'siblings-only'
          };
        },
        formatLabel: () => ({ item }) => item?.name || item?.id || '',
        buildChain: (manifest, options) => buildPlacesChain(manifest, options),
        createHandlers: params => {
          const adapter = adapterLoader.load('places');
          return adapter?.createHandlers ? adapter.createHandlers(params) : { parentHandler: () => false, childrenHandler: () => false, layoutBindings: {} };
        }
      }
    };

    function resolveVolumeFromPath(path) {
      const lower = (path || '').toLowerCase();
      const match = Object.values(volumeConfigs).find(cfg => cfg.paths?.some(p => lower.includes(p)));
      return match?.id || null;
    }

    async function loadConfig() {
      const params = new URLSearchParams(window.location.search);
      const path = (window.location.pathname || '').toLowerCase();
      const paramVolume = params.get('volume');
      const resolvedVolume = volumeConfigs[paramVolume]?.id || resolveVolumeFromPath(path) || DEFAULT_VOLUME;
      const config = volumeConfigs[resolvedVolume];
      const manifest = await fetch(config.manifestPath).then(r => r.json());
      const root = config.extractRoot(manifest);
      const validation = validateVolumeRoot(root);
      if (!validation.ok) {
        console.error('[wheel] volume validation failed', { errors: validation.errors, warnings: validation.warnings });
        throw new Error('Invalid volume manifest');
      }
      if (validation.warnings.length) {
        console.warn('[wheel] volume validation warnings', validation.warnings);
      }
      const startup = root?.display_config?.focus_ring_startup || {};
      const arrangements = root?.display_config?.focus_ring_arrangements || {};
      const supplemental = await config.loadSupplemental(root, manifest, params);
      const options = config.buildOptions({ params, startup, arrangements });
      return { volume: resolvedVolume, config, manifest, root, options, supplemental };
    }

    function applyTheme(manifest, volume) {
      const theme = volumeConfigs[volume]?.theme || volume;
      const root = document.documentElement;
      root.setAttribute('data-theme', theme);
      const link = document.getElementById('volume-style');
      if (link) {
        link.setAttribute('href', `./styles/${theme}.css`);
      }
    }

    const detailRegistry = new DetailPluginRegistry();
    detailRegistry.register(new TextDetailPlugin());
    detailRegistry.register(new CardDetailPlugin());
    const detailPanel = document.getElementById('detail-panel');
    const detailContent = document.getElementById('detail-content');

    function renderDetail(selected, adapterInstance, manifest, adapterNormalized) {
      if (!detailPanel || !detailContent) return;
      while (detailContent.firstChild) detailContent.removeChild(detailContent.firstChild);
      if (!selected) return;
      const payload = adapterInstance?.detailFor
        ? adapterInstance.detailFor(selected, manifest, { normalized: adapterNormalized })
        : { type: 'text', text: selected.name || selected.id || '' };
      if (!payload) return;
      const plugin = detailRegistry.getPlugin(payload);
      if (!plugin) return;
      const bounds = detailPanel.getBoundingClientRect();
      const node = plugin.render(payload, { width: bounds.width, height: bounds.height }, { createElement: tag => document.createElement(tag) });
      if (node) detailContent.appendChild(node);
    }

    function makeBibleLabelFormatter({ level, locale, namesMap }) {
      const translations = {
        english: { chapter: 'Chapter', verse: 'Verse', bc: 'B.C.', ad: 'A.D.' }
      };
      const t = key => translations[locale]?.[key] || translations.english[key] || key;
      const getYearNumber = item => {
        if (Number.isFinite(item?.yearNumber)) return item.yearNumber;
        const parsed = Number.parseInt(item?.id, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      const formatChapter = ({ item, context }) => {
        const chapterVal = item?.chapter ?? (() => {
          const asNumber = Number.parseInt(item?.name, 10);
          if (Number.isFinite(asNumber)) return asNumber;
          return item?.name;
        })();
        if (context === 'node') return String(chapterVal ?? item?.id ?? '');
        return `${t('chapter')} ${chapterVal ?? item?.id ?? ''}`.trim();
      };
      const formatVerse = ({ item, context }) => {
        const extract = () => {
          if (item?.verse !== undefined) return item.verse;
          if (typeof item?.name === 'string' && item.name.includes(':')) {
            const parts = item.name.split(':');
            return parts[parts.length - 1];
          }
          return item?.name;
        };
        const verseVal = extract();
        if (context === 'node') return String(verseVal ?? item?.id ?? '');
        return `${t('verse')} ${verseVal ?? item?.id ?? ''}`.trim();
      };
      const bookNames = namesMap?.books || namesMap;
      return ({ item, context }) => {
        if (!item) return '';
        const yearNumber = getYearNumber(item);
        if (Number.isFinite(yearNumber)) {
          if (context === 'node') return String(Math.abs(yearNumber));
          const era = yearNumber < 0 ? t('bc') : t('ad');
          return `${Math.abs(yearNumber)} ${era}`;
        }
        const localizedBook = bookNames?.[item.id];
        if (level === 'chapter') return formatChapter({ item, context });
        if (level === 'verse') return formatVerse({ item, context });
        return localizedBook || item.name || item.id || '';
      };
    }

    function makeCalendarLabelFormatter({ locale }) {
      const translations = { english: { bc: 'B.C.', ad: 'A.D.' } };
      const t = key => translations[locale]?.[key] || translations.english[key] || key;
      const getYearNumber = item => {
        if (Number.isFinite(item?.yearNumber)) return item.yearNumber;
        const parsed = Number.parseInt(item?.id, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      return ({ item, context }) => {
        if (!item) return '';
        const yearNumber = getYearNumber(item);
        if (!Number.isFinite(yearNumber)) return item?.name || item?.id || '';
        if (context === 'node') return String(Math.abs(yearNumber));
        const era = yearNumber < 0 ? t('bc') : t('ad');
        return `${Math.abs(yearNumber)} ${era}`;
      };
    }

    function makeLabelFormatter({ config, volume, level, locale, namesMap, options, manifest, meta }) {
      const factory = config?.formatLabel || (() => ({ item }) => item?.name || item?.id || '');
      return factory({ volume, level, locale, namesMap, options, manifest, meta });
    }

    function buildBibleChain(manifest, options, namesMap) {
      const arrangement = options.arrangement;
      const initialItemId = options.initialItemId;
      if (options.cousinMode && (arrangement || 'cousins-with-gaps') !== 'siblings-only') {
        const level = options.level || 'book';
        if (level === 'verse') {
          return buildBibleVerseCousinChain(manifest, {
            bookId: options.bookId || 'GENE',
            startChapterId: options.chapterId || undefined,
            translation: options.translation || 'NAB'
          });
        }
        const chain = buildBibleBookCousinChain(manifest, {
          testamentId: options.testamentId,
          bookId: options.bookId || 'GENE',
          initialItemId,
          names: namesMap
        });
        if (namesMap && typeof namesMap === 'object') {
          const bookNames = namesMap.books || namesMap;
          chain.items = chain.items.map(item => item ? { ...item, name: bookNames[item.id] || item.name } : item);
        }
        return chain;
      }
      const items = buildBibleBooks(manifest, namesMap)
        .sort((a, b) => {
          const as = a.sort || 0;
          const bs = b.sort || 0;
          if (as === bs) return (a.name || '').localeCompare(b.name || '');
          return as - bs;
        })
        .map((item, idx) => ({ ...item, order: idx }));
      const selectedIndex = (() => {
        if (initialItemId) {
          const idx = items.findIndex(item => item && (item.id === initialItemId));
          if (idx >= 0) return idx;
        }
        return 0;
      })();
      return { items, selectedIndex, preserveOrder: false };
    }

    function buildPlacesChain(manifest, options) {
      const levels = getPlacesLevels(manifest);
      if (!levels.length) return { items: [], selectedIndex: 0, preserveOrder: true, meta: null };
      const startLevel = levels.includes(options.level) ? options.level : levels[0];
      const levelIndex = Math.max(0, levels.indexOf(startLevel));
      const { items, selectedIndex, preserveOrder } = buildPlacesLevel(manifest, levels, levelIndex, {
        selectedId: options.initialItemId || null
      });
      const selections = { [startLevel]: items[selectedIndex]?.id || options.initialItemId || null };
      return { items, selectedIndex, preserveOrder, meta: { levels, levelIndex, selections } };
    }


    function wireInteractions(app, itemCount) {
      let isDragging = false;
      let isSecondaryDragging = false;
      let lastX = 0;
      let lastY = 0;
      let lastTime = 0;
      const isInteractionLocked = () => Boolean(app?.isBlurred?.());
      const hasSecondary = () => Boolean(app?.hasSecondary?.());
      const sensitivity = Math.PI / 4 / 100; // 100px → 45°
      const velocityThreshold = 0.4; // px/ms below this → no gain
      const gainSlope = 1.1; // linear slope past threshold
      const baseQuickNodes = 60; // empirical baseline nodes per quick swipe at gain 1
      const targetSpinNodes = 350; // fixed quick-flick span for consistency across devices
      const baseMaxGain = Math.max(1, targetSpinNodes / baseQuickNodes);

      const onPointerMove = event => {
        if (!isDragging && !isSecondaryDragging) return;
        if (isInteractionLocked() && !isSecondaryDragging) {
          isDragging = false;
          return;
        }
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        const dt = event.timeStamp - lastTime;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;

        const distance = Math.abs(dx) + Math.abs(dy);
        const velocity = dt > 0 ? distance / dt : 0;
        const maxGain = baseMaxGain;
        const gain = velocity <= velocityThreshold
          ? 1
          : Math.min(maxGain, 1 + (velocity - velocityThreshold) * gainSlope);

        const delta = -(dx + dy) * sensitivity * gain;
        if (isSecondaryDragging) {
          app.rotateSecondary(delta);
        } else {
          app.choreographer.rotate(delta);
        }
      };

      svg.addEventListener('pointerdown', event => {
        const isDimensionButton = event.target && event.target.closest && event.target.closest('.dimension-button');
        if (isDimensionButton) {
          return; // let the Dimension button handle its own toggle without starting a drag
        }
        const blurred = isInteractionLocked();
        if (blurred && hasSecondary()) {
          isSecondaryDragging = true;
          isDragging = false;
          lastX = event.clientX;
          lastY = event.clientY;
          lastTime = event.timeStamp;
          app.beginSecondaryRotation();
          return;
        }
        if (blurred) {
          isDragging = false;
          app.choreographer.stopMomentum();
          return;
        }
        const isNode = event.target && event.target.closest && event.target.closest('.focus-ring-node');
        if (isNode) {
          return; // click handler on node will manage rotation
        }
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;
      });

      svg.addEventListener('pointermove', onPointerMove);

      ['pointerup', 'pointercancel', 'pointerleave'].forEach(type => {
        svg.addEventListener(type, () => {
          if (isSecondaryDragging) {
            isSecondaryDragging = false;
            if (app.endSecondaryRotation) app.endSecondaryRotation();
            return;
          }
          isDragging = false;
          if (isInteractionLocked()) return;
          app.selectNearest();
          app.choreographer.stopMomentum();
        });
      });
    }

    async function showVersion() {
      const badge = document.getElementById('version-badge');
      if (!badge) return;
      try {
        const pkg = await fetch('./package.json').then(r => r.json());
        const name = pkg?.name || 'wheel';
        const version = pkg?.version ? `v${pkg.version}` : 'v?';
        badge.textContent = `${name} ${version}`;
      } catch (err) {
        console.warn('Version load failed', err);
        badge.textContent = 'version unavailable';
      }
    }

    const translationsForLanguage = (translationsMeta, language) => {
      const translations = translationsMeta?.translations || {};
      const entries = Object.entries(translations)
        .filter(([, t]) => t?.language === language);
      if (!entries.length) return null;
      const both = entries.find(([, t]) => (t?.testament || '').toLowerCase() === 'both');
      if (both) return both[0];
      return entries[0][0];
    };

    loadConfig().then(async ({ volume, config, manifest, options, supplemental }) => {
      applyTheme(manifest, volume);
      const translationsMeta = supplemental?.translationsMeta || null;
      const fallbackTranslation = translationsForLanguage(translationsMeta, options?.locale || 'english') || 'NAB';
      const translationId = options.translation || fallbackTranslation;
      const translationLang = translationsMeta?.translations?.[translationId]?.language || options.locale || 'english';
      const resolvedLocale = options.locale || translationLang || 'english';
      const localeNames = translationsMeta?.names?.[translationLang] || {};
      const namesMap = {
        books: localeNames.books || localeNames,
        sections: localeNames.sections || {}
      };

      const chainResult = await config.buildChain(manifest, options, namesMap);
      const { items, selectedIndex = 0, preserveOrder = false, meta } = chainResult;
      const handlerSet = config.createHandlers({ manifest, namesMap, options, translationsMeta, chainMeta: chainResult });
      const secondary = handlerSet.secondary || { items: [], selectedIndex: 0 };
      if (!items.length) {
        console.error('No items found for volume', volume);
        return;
      }

      const adapter = adapterLoader.load(volume);
      let adapterNormalized = null;
      let adapterLayoutSpec = null;
      if (adapter) {
        try {
          adapterNormalized = adapter.normalize(manifest);
          adapterLayoutSpec = adapter.layoutSpec(adapterNormalized, viewport);
        } catch (err) {
          console.warn('[wheel] adapter layoutSpec failed, falling back to host config', err);
          adapterNormalized = null;
          adapterLayoutSpec = null;
        }
      }

      const adapterLabel = adapterLayoutSpec?.label;
      const labelFormatter = adapterLabel
        ? ({ item }) => adapterLabel(item)
        : makeLabelFormatter({ config, volume, level: options.level, locale: resolvedLocale, namesMap, options, manifest, meta });
      const shouldCenterLabel = handlerSet.shouldCenterLabel || (() => Boolean(config?.centerLabel));
      let app;

      const parentHandler = params => (handlerSet.parentHandler ? handlerSet.parentHandler({ ...params, app }) : false);
      const childrenHandler = params => (handlerSet.childrenHandler ? handlerSet.childrenHandler({ ...params, app }) : false);

      const layoutBindings = handlerSet.layoutBindings || {};
      const layoutSpec = createVolumeLayoutSpec({
        volume,
        manifest,
        namesMap,
        placesState: layoutBindings.placesState,
        buildPlacesLevel,
        placesChildrenHandler: layoutBindings.placesChildrenHandler,
        getCatalogChildren: layoutBindings.getCatalogChildren || ((m, selected) => getCatalogChildren(manifest, selected)),
        getCalendarMonths: layoutBindings.getCalendarMonths || ((m, selected, mode) => getCalendarMonths(manifest, selected, mode)),
        getBibleChapters: layoutBindings.getBibleChapters || ((m, selected, nm, mode) => getBibleChapters(manifest, selected, nm, mode)),
        getApp: () => app,
        calendarModeRef: layoutBindings.calendarModeRef,
        setCalendarMode: layoutBindings.setCalendarMode,
        setCalendarMonthContext: layoutBindings.setCalendarMonthContext,
        bibleModeRef: layoutBindings.bibleModeRef,
        setBibleMode: layoutBindings.setBibleMode,
        setBibleChapterContext: layoutBindings.setBibleChapterContext,
        catalogModeRef: layoutBindings.catalogModeRef,
        setCatalogMode: layoutBindings.setCatalogMode,
        pyramidBuilder: layoutBindings.pyramidBuilder
      });
      const pyramidLayout = adapterLayoutSpec || layoutSpec;
      const pyramidConfig = pyramidLayout?.pyramid || null;
      const normalized = {
        items,
        links: (items || [])
          .filter(item => item?.parentId)
          .map(item => ({ from: item.parentId, to: item.id })),
        meta: { volumeId: volume }
      };

      const onSelectSecondary = handlerSet.onSelectSecondary
        || (secondary?.items?.length
          ? translationId => {
              const url = new URL(window.location.href);
              const currentItem = app?.nav?.getCurrent?.();
              if (currentItem?.id) {
                url.searchParams.set('item', currentItem.id);
              }
              url.searchParams.set('translation', translationId);
              url.searchParams.set('dimension', '1');
              window.location.href = url.toString();
            }
          : undefined);

      app = createApp({
        svgRoot: svg,
        items,
        viewport,
        selectedIndex,
        preserveOrder,
        labelFormatter,
        shouldCenterLabel,
        secondaryItems: secondary.items,
        secondarySelectedIndex: secondary.selectedIndex,
        contextOptions: { ...options, locale: resolvedLocale },
        onParentClick: parentHandler,
        onChildrenClick: childrenHandler,
        pyramid: pyramidConfig,
        pyramidLayoutSpec: pyramidLayout,
        pyramidNormalized: adapterNormalized || normalized,
        pyramidAdapter: adapter,
        onSelectSecondary
      });
      if (options.dimensionEnabled && app?.setBlur) {
        app.setBlur(true);
      }
      renderDetail(app?.nav?.getCurrent?.(), adapter, manifest, adapterNormalized);
      app?.nav?.onChange?.(() => renderDetail(app?.nav?.getCurrent?.(), adapter, manifest, adapterNormalized));
      wireInteractions(app, items.length);
      showVersion();
    }).catch(err => {
      console.error('Failed to initialize app', err);
    });
  </script>
</body>
</html>
