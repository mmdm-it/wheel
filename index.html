<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wheel v3 Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./styles/base.css" />
</head>
<body>
  <div id="version-badge" class="version-badge" aria-label="Application version"></div>
  <svg id="app" aria-label="Wheel v3"></svg>
  <script type="module">
    import { createApp, getViewportInfo } from './src/index.js';

    const svg = document.getElementById('app');
    const viewport = getViewportInfo(window.innerWidth, window.innerHeight);

    async function loadConfig() {
      const params = new URLSearchParams(window.location.search);
      const path = (window.location.pathname || '').toLowerCase();
      const paramVolume = params.get('volume');
      const pathVolume = path.includes('/catalog')
        ? 'catalog'
        : path.includes('/calendar')
          ? 'calendar'
          : path.includes('/bible')
            ? 'bible'
            : null;
      const volume = ['catalog', 'calendar', 'bible'].includes(paramVolume)
        ? paramVolume
        : pathVolume || 'bible';

      const manifestPath = volume === 'catalog'
        ? './data/mmdm/mmdm_catalog.json'
        : volume === 'calendar'
          ? './data/calendar/manifest.json'
          : './data/gutenberg/manifest.json';

      console.info('[wheel-v3] volume selection', {
        pathname: path,
        paramVolume,
        pathVolume,
        resolvedVolume: volume,
        manifestPath
      });

      const manifest = await fetch(manifestPath).then(r => r.json());
      return { volume, manifest };
    }

    function applyTheme(manifest, volume) {
      const root = document.documentElement;
      const theme = volume === 'catalog' ? 'catalog' : volume === 'calendar' ? 'calendar' : 'bible';
      root.setAttribute('data-theme', theme);
    }

    function buildBibleBooks(manifest) {
      const testaments = manifest?.Gutenberg_Bible?.testaments;
      if (!testaments) return [];
      const items = [];
      Object.entries(testaments).forEach(([testamentId, testament]) => {
        const sections = testament?.sections || {};
        Object.entries(sections).forEach(([sectionId, section]) => {
          const books = section?.books || {};
          Object.entries(books).forEach(([bookId, book]) => {
            items.push({
              id: bookId,
              name: book?.book_name || book?.name || bookId,
              sort: book?.sort_number || items.length + 1
            });
          });
        });
      });
      return items;
    }

    function buildCatalogManufacturers(manifest) {
      const markets = manifest?.MMdM?.markets;
      if (!markets) return [];
      const items = [];
      Object.entries(markets).forEach(([marketId, market]) => {
        const countries = market?.countries || {};
        Object.entries(countries).forEach(([countryId, country]) => {
          const manufacturers = country?.manufacturers || {};
          Object.entries(manufacturers).forEach(([manufacturerId, manufacturer]) => {
            items.push({
              id: `${marketId}__${countryId}__${manufacturerId}`,
              name: manufacturerId,
              sort: manufacturer?.sort_number || items.length + 1
            });
          });
        });
      });
      return items;
    }

    function buildCalendarYears(manifest) {
      const years = manifest?.Calendar?.years;
      if (!years) return [];
      const items = Object.values(years).map(year => {
        const yearNumber = Number.isFinite(year?.year_number) ? year.year_number : parseInt(year?.id, 10);
        const name = year?.name || (Number.isFinite(yearNumber) ? (yearNumber < 0 ? `${Math.abs(yearNumber)} BC` : `${yearNumber} AD`) : String(year?.id || ''));
        const sort = Number.isFinite(year?.sort_number) ? year.sort_number : yearNumber || 0;
        return {
          id: year?.id || String(yearNumber),
          name,
          sort
        };
      });
      return items.sort((a, b) => (a.sort || 0) - (b.sort || 0));
    }

    function buildChain(manifest, volume) {
      if (volume === 'catalog') {
        return buildCatalogManufacturers(manifest);
      }
      if (volume === 'calendar') {
        return buildCalendarYears(manifest);
      }
      return buildBibleBooks(manifest);
    }

    function wireInteractions(app) {
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      const sensitivity = Math.PI / 4 / 100; // 100px â†’ 45Â°

      const onPointerMove = event => {
        if (!isDragging) return;
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        lastX = event.clientX;
        lastY = event.clientY;
        const delta = -(dx + dy) * sensitivity;
        app.choreographer.rotate(delta);
      };

      svg.addEventListener('pointerdown', event => {
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
      });

      svg.addEventListener('pointermove', onPointerMove);

      ['pointerup', 'pointercancel', 'pointerleave'].forEach(type => {
        svg.addEventListener(type, () => {
          isDragging = false;
          app.selectNearest();
          app.choreographer.stopMomentum();
        });
      });
    }

    async function showVersion() {
      const badge = document.getElementById('version-badge');
      if (!badge) return;
      try {
        const pkg = await fetch('./package.json').then(r => r.json());
        const name = pkg?.name || 'wheel';
        const version = pkg?.version ? `v${pkg.version}` : 'v?';
        badge.textContent = `${name} ${version}`;
      } catch (err) {
        console.warn('Version load failed', err);
        badge.textContent = 'version unavailable';
      }
    }

    loadConfig().then(({ volume, manifest }) => {
      applyTheme(manifest, volume);
      const items = buildChain(manifest, volume);
      if (!items.length) {
        console.error('No items found for volume', volume);
        return;
      }
      const app = createApp({ svgRoot: svg, items, viewport });
      wireInteractions(app);
      showVersion();
    }).catch(err => {
      console.error('Failed to initialize app', err);
    });
  </script>
</body>
</html>
