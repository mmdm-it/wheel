<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wheel v3 Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./styles/base.css" />
  <link id="volume-style" rel="stylesheet" href="" />
  <link rel="icon" href="data:," />
</head>
<body>
  <div id="version-badge" class="version-badge" aria-label="Application version"></div>
  <svg id="app" aria-label="Wheel v3"></svg>
  <div id="detail-panel" class="detail-panel" aria-label="Detail panel">
    <div id="detail-content" class="detail-content"></div>
  </div>
  <script type="module">
    import { createApp, getViewportInfo, buildBibleVerseCousinChain, buildBibleBookCousinChain, validateVolumeRoot } from './src/index.js';
    import { getPlacesLevels, buildPlacesLevel, buildCalendarYears, buildCalendarMillennia, buildBibleSections, buildBibleBooks, buildCatalogManufacturers } from './src/adapters/volume-helpers.js';
    import { createVolumeLayoutSpec } from './src/adapters/volume-layout.js';
    import { createAdapterRegistry, createAdapterLoader } from './src/adapters/registry.js';
    import { catalogAdapter } from './src/adapters/catalog-adapter.js';
    import { DetailPluginRegistry } from './src/view/detail/plugin-registry.js';
    import { TextDetailPlugin } from './src/view/detail/plugins/text-plugin.js';
    import { CardDetailPlugin } from './src/view/detail/plugins/card-plugin.js';

    const svg = document.getElementById('app');
    const viewport = getViewportInfo(window.innerWidth, window.innerHeight);
    const adapterRegistry = createAdapterRegistry();
    adapterRegistry.register('catalog', () => ({ ...catalogAdapter, volumeId: 'catalog' }));
    const adapterLoader = createAdapterLoader(adapterRegistry);

    const DEFAULT_VOLUME = 'bible';
    const volumeConfigs = {
      bible: {
        id: 'bible',
        paths: ['/bible'],
        manifestPath: './data/gutenberg/manifest.json',
        theme: 'bible',
        extractRoot: manifest => manifest?.Gutenberg_Bible,
        async loadSupplemental() {
          const translationsMeta = await fetch('./data/gutenberg/translations.json').then(r => r.json()).catch(() => null);
          return { translationsMeta };
        },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || 'book';
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-with-gaps';
          const cousinParam = params.get('cousins');
          const cousinMode = cousinParam === null ? arrangement !== 'siblings-only' : cousinParam === '1';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            bookId: params.get('book') || 'GENE',
            testamentId: params.get('testament'),
            chapterId: params.get('chapter'),
            translation: params.get('translation') || 'NAB',
            cousinMode,
            locale: params.get('lang') || null,
            dimensionEnabled: params.get('dimension') === '1'
          };
        },
        formatLabel: ({ level, locale, namesMap }) => makeBibleLabelFormatter({ level, locale, namesMap }),
        buildChain: (manifest, options, namesMap) => buildBibleChain(manifest, options, namesMap),
        createHandlers: ({ manifest, namesMap, options, translationsMeta, chainMeta }) => createBibleHandlers({ manifest, namesMap, options, translationsMeta, chainMeta })
      },
      catalog: {
        id: 'catalog',
        paths: ['/catalog'],
        manifestPath: './data/mmdm/mmdm_catalog.json',
        theme: 'catalog',
        extractRoot: manifest => manifest?.MMdM,
        async loadSupplemental() { return { translationsMeta: null }; },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || 'manufacturer';
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-flat';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            locale: params.get('lang') || null,
            cousinMode: arrangement !== 'siblings-only'
          };
        },
        formatLabel: () => ({ item }) => item?.name || item?.id || '',
        buildChain: (manifest, options) => buildCatalogManufacturers(manifest, { initialItemId: options.initialItemId }),
        createHandlers: ({ manifest, options, chainMeta }) => createCatalogHandlers({ manifest, options, chainMeta })
      },
      calendar: {
        id: 'calendar',
        paths: ['/calendar'],
        manifestPath: './data/calendar/manifest.json',
        theme: 'calendar',
        extractRoot: manifest => manifest?.Calendar,
        async loadSupplemental() { return { translationsMeta: null }; },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || 'year';
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-with-gaps';
          const cousinParam = params.get('cousins');
          const cousinMode = cousinParam === null ? arrangement !== 'siblings-only' : cousinParam === '1';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            locale: params.get('lang') || null,
            cousinMode
          };
        },
        formatLabel: ({ locale }) => makeCalendarLabelFormatter({ locale }),
        buildChain: (manifest, options) => buildCalendarYears(manifest, { arrangement: options.arrangement, initialItemId: options.initialItemId }),
        createHandlers: ({ manifest, options, translationsMeta, chainMeta }) => createCalendarHandlers({ manifest, options, translationsMeta, chainMeta })
      },
      places: {
        id: 'places',
        paths: ['/places'],
        manifestPath: './data/places/manifest.json',
        theme: 'places',
        extractRoot: manifest => manifest?.Places,
        async loadSupplemental() { return { translationsMeta: null }; },
        buildOptions: ({ params, startup = {}, arrangements = {} }) => {
          const level = params.get('level') || startup.top_navigation_level || null;
          const arrangement = params.get('arrangement') || arrangements[level] || startup.arrangement || 'cousins-flat';
          return {
            level,
            arrangement,
            initialItemId: params.get('item') || startup.initial_magnified_item || null,
            locale: params.get('lang') || null,
            cousinMode: arrangement !== 'siblings-only'
          };
        },
        formatLabel: () => ({ item }) => item?.name || item?.id || '',
        buildChain: (manifest, options) => buildPlacesChain(manifest, options),
        createHandlers: ({ manifest, options, chainMeta }) => createPlacesHandlers({ manifest, options, chainMeta })
      }
    };

    function resolveVolumeFromPath(path) {
      const lower = (path || '').toLowerCase();
      const match = Object.values(volumeConfigs).find(cfg => cfg.paths?.some(p => lower.includes(p)));
      return match?.id || null;
    }

    async function loadConfig() {
      const params = new URLSearchParams(window.location.search);
      const path = (window.location.pathname || '').toLowerCase();
      const paramVolume = params.get('volume');
      const resolvedVolume = volumeConfigs[paramVolume]?.id || resolveVolumeFromPath(path) || DEFAULT_VOLUME;
      const config = volumeConfigs[resolvedVolume];
      const manifest = await fetch(config.manifestPath).then(r => r.json());
      const root = config.extractRoot(manifest);
      const validation = validateVolumeRoot(root);
      if (!validation.ok) {
        console.error('[wheel] volume validation failed', { errors: validation.errors, warnings: validation.warnings });
        throw new Error('Invalid volume manifest');
      }
      if (validation.warnings.length) {
        console.warn('[wheel] volume validation warnings', validation.warnings);
      }
      const startup = root?.display_config?.focus_ring_startup || {};
      const arrangements = root?.display_config?.focus_ring_arrangements || {};
      const supplemental = await config.loadSupplemental(root, manifest, params);
      const options = config.buildOptions({ params, startup, arrangements });
      return { volume: resolvedVolume, config, manifest, root, options, supplemental };
    }

    function applyTheme(manifest, volume) {
      const theme = volumeConfigs[volume]?.theme || volume;
      const root = document.documentElement;
      root.setAttribute('data-theme', theme);
      const link = document.getElementById('volume-style');
      if (link) {
        link.setAttribute('href', `./styles/${theme}.css`);
      }
    }

    const detailRegistry = new DetailPluginRegistry();
    detailRegistry.register(new TextDetailPlugin());
    detailRegistry.register(new CardDetailPlugin());
    const detailPanel = document.getElementById('detail-panel');
    const detailContent = document.getElementById('detail-content');

    function renderDetail(selected, adapterInstance, manifest, adapterNormalized) {
      if (!detailPanel || !detailContent) return;
      while (detailContent.firstChild) detailContent.removeChild(detailContent.firstChild);
      if (!selected) return;
      const payload = adapterInstance?.detailFor
        ? adapterInstance.detailFor(selected, manifest, { normalized: adapterNormalized })
        : { type: 'text', text: selected.name || selected.id || '' };
      if (!payload) return;
      const plugin = detailRegistry.getPlugin(payload);
      if (!plugin) return;
      const bounds = detailPanel.getBoundingClientRect();
      const node = plugin.render(payload, { width: bounds.width, height: bounds.height }, { createElement: tag => document.createElement(tag) });
      if (node) detailContent.appendChild(node);
    }

    function makeBibleLabelFormatter({ level, locale, namesMap }) {
      const translations = {
        english: { chapter: 'Chapter', verse: 'Verse', bc: 'B.C.', ad: 'A.D.' }
      };
      const t = key => translations[locale]?.[key] || translations.english[key] || key;
      const getYearNumber = item => {
        if (Number.isFinite(item?.yearNumber)) return item.yearNumber;
        const parsed = Number.parseInt(item?.id, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      const formatChapter = ({ item, context }) => {
        const chapterVal = item?.chapter ?? (() => {
          const asNumber = Number.parseInt(item?.name, 10);
          if (Number.isFinite(asNumber)) return asNumber;
          return item?.name;
        })();
        if (context === 'node') return String(chapterVal ?? item?.id ?? '');
        return `${t('chapter')} ${chapterVal ?? item?.id ?? ''}`.trim();
      };
      const formatVerse = ({ item, context }) => {
        const extract = () => {
          if (item?.verse !== undefined) return item.verse;
          if (typeof item?.name === 'string' && item.name.includes(':')) {
            const parts = item.name.split(':');
            return parts[parts.length - 1];
          }
          return item?.name;
        };
        const verseVal = extract();
        if (context === 'node') return String(verseVal ?? item?.id ?? '');
        return `${t('verse')} ${verseVal ?? item?.id ?? ''}`.trim();
      };
      const bookNames = namesMap?.books || namesMap;
      return ({ item, context }) => {
        if (!item) return '';
        const yearNumber = getYearNumber(item);
        if (Number.isFinite(yearNumber)) {
          if (context === 'node') return String(Math.abs(yearNumber));
          const era = yearNumber < 0 ? t('bc') : t('ad');
          return `${Math.abs(yearNumber)} ${era}`;
        }
        const localizedBook = bookNames?.[item.id];
        if (level === 'chapter') return formatChapter({ item, context });
        if (level === 'verse') return formatVerse({ item, context });
        return localizedBook || item.name || item.id || '';
      };
    }

    function makeCalendarLabelFormatter({ locale }) {
      const translations = { english: { bc: 'B.C.', ad: 'A.D.' } };
      const t = key => translations[locale]?.[key] || translations.english[key] || key;
      const getYearNumber = item => {
        if (Number.isFinite(item?.yearNumber)) return item.yearNumber;
        const parsed = Number.parseInt(item?.id, 10);
        return Number.isFinite(parsed) ? parsed : null;
      };
      return ({ item, context }) => {
        if (!item) return '';
        const yearNumber = getYearNumber(item);
        if (!Number.isFinite(yearNumber)) return item?.name || item?.id || '';
        if (context === 'node') return String(Math.abs(yearNumber));
        const era = yearNumber < 0 ? t('bc') : t('ad');
        return `${Math.abs(yearNumber)} ${era}`;
      };
    }

    function makeLabelFormatter({ config, volume, level, locale, namesMap, options, manifest, meta }) {
      const factory = config?.formatLabel || (() => ({ item }) => item?.name || item?.id || '');
      return factory({ volume, level, locale, namesMap, options, manifest, meta });
    }

    function buildBibleChain(manifest, options, namesMap) {
      const arrangement = options.arrangement;
      const initialItemId = options.initialItemId;
      if (options.cousinMode && (arrangement || 'cousins-with-gaps') !== 'siblings-only') {
        const level = options.level || 'book';
        if (level === 'verse') {
          return buildBibleVerseCousinChain(manifest, {
            bookId: options.bookId || 'GENE',
            startChapterId: options.chapterId || undefined,
            translation: options.translation || 'NAB'
          });
        }
        const chain = buildBibleBookCousinChain(manifest, {
          testamentId: options.testamentId,
          bookId: options.bookId || 'GENE',
          initialItemId,
          names: namesMap
        });
        if (namesMap && typeof namesMap === 'object') {
          const bookNames = namesMap.books || namesMap;
          chain.items = chain.items.map(item => item ? { ...item, name: bookNames[item.id] || item.name } : item);
        }
        return chain;
      }
      const items = buildBibleBooks(manifest, namesMap)
        .sort((a, b) => {
          const as = a.sort || 0;
          const bs = b.sort || 0;
          if (as === bs) return (a.name || '').localeCompare(b.name || '');
          return as - bs;
        })
        .map((item, idx) => ({ ...item, order: idx }));
      const selectedIndex = (() => {
        if (initialItemId) {
          const idx = items.findIndex(item => item && (item.id === initialItemId));
          if (idx >= 0) return idx;
        }
        return 0;
      })();
      return { items, selectedIndex, preserveOrder: false };
    }

    function buildPlacesChain(manifest, options) {
      const levels = getPlacesLevels(manifest);
      if (!levels.length) return { items: [], selectedIndex: 0, preserveOrder: true, meta: null };
      const startLevel = levels.includes(options.level) ? options.level : levels[0];
      const levelIndex = Math.max(0, levels.indexOf(startLevel));
      const { items, selectedIndex, preserveOrder } = buildPlacesLevel(manifest, levels, levelIndex, {
        selectedId: options.initialItemId || null
      });
      const selections = { [startLevel]: items[selectedIndex]?.id || options.initialItemId || null };
      return { items, selectedIndex, preserveOrder, meta: { levels, levelIndex, selections } };
    }

    function createBibleHandlers({ manifest, namesMap, options, translationsMeta }) {
      let bibleMode = 'book';
      let bibleChapterContext = null;
      const lastBookBySection = {};
      const secondary = translationsMeta ? buildSecondaryLanguages(translationsMeta, options.translation) : { items: [], selectedIndex: 0 };

      const parentHandler = ({ selected, app }) => {
        if (bibleMode === 'chapter') {
          const ctx = bibleChapterContext;
          const { items: bookItems, selectedIndex: bookSelected, preserveOrder: bookPreserve } = buildBibleBookCousinChain(manifest, {
            testamentId: ctx?.testamentId,
            initialItemId: ctx?.bookId,
            names: namesMap
          });
          if (!bookItems.length) return false;
          bibleMode = 'book';
          bibleChapterContext = null;
          if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
          if (app?.setPrimaryItems) app.setPrimaryItems(bookItems, bookSelected, bookPreserve);
          return true;
        }
        if (bibleMode !== 'book') return false;
        const sectionId = selected?.sectionId;
        if (sectionId && selected?.id) {
          lastBookBySection[sectionId] = selected.id;
        }
        const testamentId = selected?.testamentId;
        const { items: sectionItems, selectedIndex: sectionSelected } = buildBibleSections(manifest, {
          testamentId,
          sectionId,
          namesMap
        });
        if (!sectionItems.length) return false;
        bibleMode = 'section';
        if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
        if (app?.setPrimaryItems) app.setPrimaryItems(sectionItems, sectionSelected, true);
        return true;
      };

      const childrenHandler = ({ selected, app }) => {
        if (bibleMode !== 'section') return false;
        const sectionId = selected?.id;
        const testamentId = selected?.testamentId;
        const initialBookId = sectionId ? lastBookBySection[sectionId] : null;
        const { items: bookItems, selectedIndex: bookSelected, preserveOrder: bookPreserve } = buildBibleBookCousinChain(manifest, {
          testamentId,
          initialItemId: initialBookId,
          names: namesMap
        });
        if (!bookItems.length) return false;
        bibleMode = 'book';
        if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
        if (app?.setPrimaryItems) app.setPrimaryItems(bookItems, bookSelected, bookPreserve);
        return true;
      };

      return {
        parentHandler,
        childrenHandler,
        secondary,
        layoutBindings: {
          bibleModeRef: () => bibleMode,
          setBibleMode: next => { bibleMode = next; },
          setBibleChapterContext: ctx => { bibleChapterContext = ctx; }
        }
      };
    }

    function createCalendarHandlers({ manifest, options }) {
      let calendarMode = 'year';
      let calendarMonthContext = null;
      const lastYearByMillennium = {};

      const parentHandler = ({ selected, app }) => {
        if (calendarMode === 'month') {
          const yearId = calendarMonthContext?.yearId;
          const milliId = calendarMonthContext?.millenniumId;
          const { items: yearItems, selectedIndex: yearSelected } = buildCalendarYears(manifest, {
            arrangement: options.arrangement,
            initialItemId: yearId,
            filterMillenniumId: milliId
          });
          calendarMode = 'year';
          if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
          if (app?.setPrimaryItems) app.setPrimaryItems(yearItems, yearSelected, true);
          return true;
        }
        if (calendarMode !== 'year') return false;
        const millenniumId = selected?.parentId || selected?.parent_id || null;
        if (millenniumId && selected?.id) {
          lastYearByMillennium[millenniumId] = selected.id;
        }
        const { items: milliItems, selectedIndex: milliSelected } = buildCalendarMillennia(manifest, { initialItemId: millenniumId });
        calendarMode = 'millennium';
        if (app?.setParentButtons) app.setParentButtons({ showOuter: false, showInner: true });
        if (app?.setPrimaryItems) app.setPrimaryItems(milliItems, milliSelected, true);
        return true;
      };

      const childrenHandler = ({ selected, app }) => {
        if (calendarMode === 'year') {
          const months = getCalendarMonths(manifest, selected, calendarMode);
          if (!months.length) return false;
          calendarMode = 'month';
          calendarMonthContext = {
            yearId: selected?.id || null,
            millenniumId: selected?.parentId || selected?.parent_id || null
          };
          if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
          if (app?.setPrimaryItems) app.setPrimaryItems(months, 0, true);
          return true;
        }
        if (calendarMode !== 'millennium') return false;
        const millenniumId = selected?.id;
        if (!millenniumId) return true;
        const preferredYear = lastYearByMillennium[millenniumId];
        const { items: yearItems, selectedIndex: yearSelected } = buildCalendarYears(manifest, {
          arrangement: options.arrangement,
          initialItemId: preferredYear,
          filterMillenniumId: millenniumId
        });
        calendarMode = 'year';
        if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
        if (app?.setPrimaryItems) app.setPrimaryItems(yearItems, yearSelected, true);
        return true;
      };

      return {
        parentHandler,
        childrenHandler,
        shouldCenterLabel: () => true,
        layoutBindings: {
          calendarModeRef: () => calendarMode,
          setCalendarMode: next => { calendarMode = next; },
          setCalendarMonthContext: ctx => { calendarMonthContext = ctx; },
          getCalendarMonths: (m, selected, mode) => getCalendarMonths(manifest, selected, mode || calendarMode)
        }
      };
    }

    function createCatalogHandlers({ chainMeta }) {
      let catalogMode = 'manufacturer';
      const catalogRoot = chainMeta ? { ...chainMeta } : null;

      const parentHandler = ({ app }) => {
        if (catalogMode !== 'model') return false;
        if (!catalogRoot) return false;
        catalogMode = 'manufacturer';
        if (app?.setParentButtons) app.setParentButtons({ showOuter: true, showInner: true });
        if (app?.setPrimaryItems) {
          const { items: rootItems, selectedIndex: rootSelected, preserveOrder: rootPreserve } = catalogRoot;
          app.setPrimaryItems(rootItems || [], rootSelected ?? 0, rootPreserve ?? false);
        }
        return true;
      };

      return {
        parentHandler,
        childrenHandler: () => false,
        layoutBindings: {
          catalogModeRef: () => catalogMode,
          setCatalogMode: next => { catalogMode = next; }
        }
      };
    }

    function createPlacesHandlers({ manifest, chainMeta }) {
      const baseState = chainMeta?.meta ? chainMeta.meta : chainMeta || {};
      let placesState = { ...baseState, manifest };

      const parentHandler = ({ selected, setItems, app }) => {
        if (!placesState?.levels?.length) return false;
        if (placesState.levelIndex <= 0) return false;
        const parentLevelIndex = placesState.levelIndex - 1;
        const parentLevelName = placesState.levels[parentLevelIndex];
        placesState.selections[placesState.levels[placesState.levelIndex]] = selected?.id || placesState.selections[placesState.levels[placesState.levelIndex]];
        const { items: parentItems, selectedIndex: parentSelected, preserveOrder } = buildPlacesLevel(
          placesState.manifest,
          placesState.levels,
          parentLevelIndex,
          {
            selectedId: placesState.selections[parentLevelName] || null
          }
        );
        if (!parentItems.length) return false;
        placesState.levelIndex = parentLevelIndex;
        placesState.selections[parentLevelName] = parentItems[parentSelected]?.id || placesState.selections[parentLevelName] || null;
        const apply = typeof setItems === 'function' ? setItems : app?.setPrimaryItems;
        if (apply) apply(parentItems, parentSelected, preserveOrder);
        return true;
      };

      const childrenHandler = ({ selected, setItems, app }) => {
        if (!placesState?.levels?.length) return false;
        if (placesState.levelIndex >= placesState.levels.length - 1) return false;
        if (!selected?.id) return false;
        const nextLevelIndex = placesState.levelIndex + 1;
        const nextLevelName = placesState.levels[nextLevelIndex];
        const { items: childItems, selectedIndex: childSelected, preserveOrder } = buildPlacesLevel(
          placesState.manifest,
          placesState.levels,
          nextLevelIndex,
          {
            parentItem: selected,
            selectedId: placesState.selections[nextLevelName] || null,
            contextParentId: selected.id
          }
        );
        if (!childItems.length) return false;
        placesState.levelIndex = nextLevelIndex;
        placesState.selections[nextLevelName] = childItems[childSelected]?.id || placesState.selections[nextLevelName] || null;
        const apply = typeof setItems === 'function' ? setItems : app?.setPrimaryItems;
        if (apply) apply(childItems, childSelected, preserveOrder);
        return true;
      };

      return {
        parentHandler,
        childrenHandler,
        layoutBindings: {
          placesState,
          buildPlacesLevel,
          placesChildrenHandler: params => childrenHandler(params)
        }
      };
    }

    function wireInteractions(app, itemCount) {
      let isDragging = false;
      let isSecondaryDragging = false;
      let lastX = 0;
      let lastY = 0;
      let lastTime = 0;
      const isInteractionLocked = () => Boolean(app?.isBlurred?.());
      const hasSecondary = () => Boolean(app?.hasSecondary?.());
      const sensitivity = Math.PI / 4 / 100; // 100px → 45°
      const velocityThreshold = 0.4; // px/ms below this → no gain
      const gainSlope = 1.1; // linear slope past threshold
      const baseQuickNodes = 60; // empirical baseline nodes per quick swipe at gain 1
      const targetSpinNodes = 350; // fixed quick-flick span for consistency across devices
      const baseMaxGain = Math.max(1, targetSpinNodes / baseQuickNodes);

      const onPointerMove = event => {
        if (!isDragging && !isSecondaryDragging) return;
        if (isInteractionLocked() && !isSecondaryDragging) {
          isDragging = false;
          return;
        }
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        const dt = event.timeStamp - lastTime;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;

        const distance = Math.abs(dx) + Math.abs(dy);
        const velocity = dt > 0 ? distance / dt : 0;
        const maxGain = baseMaxGain;
        const gain = velocity <= velocityThreshold
          ? 1
          : Math.min(maxGain, 1 + (velocity - velocityThreshold) * gainSlope);

        const delta = -(dx + dy) * sensitivity * gain;
        if (isSecondaryDragging) {
          app.rotateSecondary(delta);
        } else {
          app.choreographer.rotate(delta);
        }
      };

      svg.addEventListener('pointerdown', event => {
        const isDimensionButton = event.target && event.target.closest && event.target.closest('.dimension-button');
        if (isDimensionButton) {
          return; // let the Dimension button handle its own toggle without starting a drag
        }
        const blurred = isInteractionLocked();
        if (blurred && hasSecondary()) {
          isSecondaryDragging = true;
          isDragging = false;
          lastX = event.clientX;
          lastY = event.clientY;
          lastTime = event.timeStamp;
          app.beginSecondaryRotation();
          return;
        }
        if (blurred) {
          isDragging = false;
          app.choreographer.stopMomentum();
          return;
        }
        const isNode = event.target && event.target.closest && event.target.closest('.focus-ring-node');
        if (isNode) {
          return; // click handler on node will manage rotation
        }
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;
      });

      svg.addEventListener('pointermove', onPointerMove);

      ['pointerup', 'pointercancel', 'pointerleave'].forEach(type => {
        svg.addEventListener(type, () => {
          if (isSecondaryDragging) {
            isSecondaryDragging = false;
            if (app.endSecondaryRotation) app.endSecondaryRotation();
            return;
          }
          isDragging = false;
          if (isInteractionLocked()) return;
          app.selectNearest();
          app.choreographer.stopMomentum();
        });
      });
    }

    async function showVersion() {
      const badge = document.getElementById('version-badge');
      if (!badge) return;
      try {
        const pkg = await fetch('./package.json').then(r => r.json());
        const name = pkg?.name || 'wheel';
        const version = pkg?.version ? `v${pkg.version}` : 'v?';
        badge.textContent = `${name} ${version}`;
      } catch (err) {
        console.warn('Version load failed', err);
        badge.textContent = 'version unavailable';
      }
    }

    const translationsForLanguage = (translationsMeta, language) => {
      const translations = translationsMeta?.translations || {};
      const entries = Object.entries(translations)
        .filter(([, t]) => t?.language === language);
      if (!entries.length) return null;
      const both = entries.find(([, t]) => (t?.testament || '').toLowerCase() === 'both');
      if (both) return both[0];
      return entries[0][0];
    };

    const buildSecondaryLanguages = (translationsMeta, currentTranslation) => {
      const nativeNames = {
        latin: 'Latina',
        greek: 'Ελληνικά',
        hebrew: 'עברית',
        english: 'English',
        french: 'Français',
        spanish: 'Español',
        italian: 'Italiano',
        portuguese: 'Português',
        russian: 'Русский'
      };
      const desiredOrder = ['hebrew', 'greek', 'latin', 'french', 'spanish', 'english', 'italian', 'portuguese', 'russian'];
      const normalize = lang => (lang || '').toLowerCase().trim() === 'portugese' ? 'portuguese' : (lang || '').toLowerCase().trim();
      const translations = translationsMeta?.translations || {};
      const items = desiredOrder.map((lang, idx) => {
        const normalizedLang = normalize(lang);
        const translation = translationsForLanguage(translationsMeta, normalizedLang) || currentTranslation || 'NAB';
        const name = nativeNames[normalizedLang]
          || (translations[translation]?.language_name)
          || (normalizedLang ? `${normalizedLang.charAt(0).toUpperCase()}${normalizedLang.slice(1)}` : 'Language');
        return {
          id: normalizedLang,
          name,
          order: idx,
          translation
        };
      });
      const currentLang = translations?.[currentTranslation]?.language;
      const selectedIndex = (() => {
        if (currentLang) {
          const idx = items.findIndex(item => item.id === currentLang);
          if (idx >= 0) return idx;
        }
        return 0;
      })();
      return { items, selectedIndex };
    };

    const getCatalogChildren = (manifest, selected) => {
      const id = selected?.id;
      if (!id) return [];
      const [marketId, countryId, manufacturerId] = id.split('__');
      const manufacturer = manifest?.MMdM?.markets?.[marketId]?.countries?.[countryId]?.manufacturers?.[manufacturerId];
      if (!manufacturer) return [];
      const cylinders = manufacturer.cylinders || {};
      const children = [];
      Object.entries(cylinders).forEach(([cylKey, cylVal]) => {
        const models = Array.isArray(cylVal.models) ? cylVal.models : [];
        models.forEach((model, idx) => {
          const modelId = `model:${manufacturerId}:${cylKey}:${model.engine_model || idx}`;
          children.push({
            id: modelId,
            name: model.engine_model || modelId,
            order: idx,
            parentId: id,
            cylinder: cylKey,
            level: 'model'
          });
        });
      });
      return children.map((child, idx) => ({ ...child, order: Number.isFinite(child.order) ? child.order : idx }));
    };

    const getCalendarMonths = (manifest, selected, calendarMode) => {
      if (calendarMode !== 'year') return [];
      const yearId = selected?.id;
      if (!yearId) return [];
      const years = manifest?.Calendar?.years || {};
      const yearEntry = years[yearId] || Object.values(years).find(y => String(y.id || '') === String(yearId));
      if (!yearEntry?.months) return [];
      return Object.entries(yearEntry.months).map(([monthKey, monthVal], idx) => ({
        id: monthVal?.id || `${yearId}:${monthKey}`,
        name: monthVal?.name || monthKey,
        order: Number.isFinite(monthVal?.sort_number) ? monthVal.sort_number : idx,
        parentId: yearId,
        level: 'month'
      })).sort((a, b) => {
        if (a.order === b.order) return (a.name || '').localeCompare(b.name || '');
        return a.order - b.order;
      }).map((item, idx) => ({ ...item, order: idx }));
    };

    const getBibleChapters = (manifest, selected, namesMap, bibleMode) => {
      if (bibleMode !== 'book') return [];
      const bookId = selected?.id;
      if (!bookId) return [];
      const testaments = manifest?.Gutenberg_Bible?.testaments || {};
      let bookEntry = null;
      Object.values(testaments).some(testament => {
        const sections = testament?.sections || {};
        return Object.values(sections).some(section => {
          const books = section?.books || {};
          if (books[bookId]) {
            bookEntry = books[bookId];
            return true;
          }
          return false;
        });
      });
      if (!bookEntry?.chapters) return [];
      return Object.entries(bookEntry.chapters).map(([chapterKey, chapterVal], idx) => {
        const chapterNum = Number.parseInt(chapterKey, 10);
        const label = Number.isFinite(chapterNum) ? `Chapter ${chapterNum}` : (namesMap?.sections?.[chapterKey] || chapterKey);
        return {
          id: chapterVal?.id || `${bookId}:${chapterKey}`,
          name: chapterVal?.name || label,
          order: Number.isFinite(chapterVal?.sort_number) ? chapterVal.sort_number : idx,
          parentId: bookId,
          level: 'chapter'
        };
      }).sort((a, b) => {
        if (a.order === b.order) return (a.name || '').localeCompare(b.name || '');
        return a.order - b.order;
      }).map((item, idx) => ({ ...item, order: idx }));
    };

    loadConfig().then(async ({ volume, config, manifest, options, supplemental }) => {
      applyTheme(manifest, volume);
      const translationsMeta = supplemental?.translationsMeta || null;
      const fallbackTranslation = translationsForLanguage(translationsMeta, options?.locale || 'english') || 'NAB';
      const translationId = options.translation || fallbackTranslation;
      const translationLang = translationsMeta?.translations?.[translationId]?.language || options.locale || 'english';
      const resolvedLocale = options.locale || translationLang || 'english';
      const localeNames = translationsMeta?.names?.[translationLang] || {};
      const namesMap = {
        books: localeNames.books || localeNames,
        sections: localeNames.sections || {}
      };

      const chainResult = await config.buildChain(manifest, options, namesMap);
      const { items, selectedIndex = 0, preserveOrder = false, meta } = chainResult;
      const handlerSet = config.createHandlers({ manifest, namesMap, options, translationsMeta, chainMeta: chainResult });
      const secondary = handlerSet.secondary || { items: [], selectedIndex: 0 };
      if (!items.length) {
        console.error('No items found for volume', volume);
        return;
      }

      const labelFormatter = makeLabelFormatter({ config, volume, level: options.level, locale: resolvedLocale, namesMap, options, manifest, meta });
      const shouldCenterLabel = handlerSet.shouldCenterLabel || (() => volume === 'calendar');
      let app;

      const parentHandler = params => (handlerSet.parentHandler ? handlerSet.parentHandler({ ...params, app }) : false);
      const childrenHandler = params => (handlerSet.childrenHandler ? handlerSet.childrenHandler({ ...params, app }) : false);

      const layoutBindings = handlerSet.layoutBindings || {};
      const layoutSpec = createVolumeLayoutSpec({
        volume,
        manifest,
        namesMap,
        placesState: layoutBindings.placesState,
        buildPlacesLevel,
        placesChildrenHandler: layoutBindings.placesChildrenHandler,
        getCatalogChildren: layoutBindings.getCatalogChildren || ((m, selected) => getCatalogChildren(manifest, selected)),
        getCalendarMonths: layoutBindings.getCalendarMonths || ((m, selected, mode) => getCalendarMonths(manifest, selected, mode)),
        getBibleChapters: layoutBindings.getBibleChapters || ((m, selected, nm, mode) => getBibleChapters(manifest, selected, nm, mode)),
        getApp: () => app,
        calendarModeRef: layoutBindings.calendarModeRef,
        setCalendarMode: layoutBindings.setCalendarMode,
        setCalendarMonthContext: layoutBindings.setCalendarMonthContext,
        bibleModeRef: layoutBindings.bibleModeRef,
        setBibleMode: layoutBindings.setBibleMode,
        setBibleChapterContext: layoutBindings.setBibleChapterContext,
        catalogModeRef: layoutBindings.catalogModeRef,
        setCatalogMode: layoutBindings.setCatalogMode
      });
      const adapter = adapterLoader.load(volume);
      let adapterNormalized = null;
      let adapterLayoutSpec = null;
      if (adapter) {
        try {
          adapterNormalized = adapter.normalize(manifest);
          adapterLayoutSpec = adapter.layoutSpec(adapterNormalized, viewport);
        } catch (err) {
          console.warn('[wheel] adapter layoutSpec failed, falling back to host config', err);
          adapterNormalized = null;
          adapterLayoutSpec = null;
        }
      }

      const pyramidLayout = adapterLayoutSpec || layoutSpec;
      const pyramidConfig = pyramidLayout?.pyramid || null;
      const normalized = {
        items,
        links: (items || [])
          .filter(item => item?.parentId)
          .map(item => ({ from: item.parentId, to: item.id })),
        meta: { volumeId: volume }
      };

      const onSelectSecondary = handlerSet.onSelectSecondary
        || (secondary?.items?.length
          ? translationId => {
              const url = new URL(window.location.href);
              const currentItem = app?.nav?.getCurrent?.();
              if (currentItem?.id) {
                url.searchParams.set('item', currentItem.id);
              }
              url.searchParams.set('translation', translationId);
              url.searchParams.set('dimension', '1');
              window.location.href = url.toString();
            }
          : undefined);

      app = createApp({
        svgRoot: svg,
        items,
        viewport,
        selectedIndex,
        preserveOrder,
        labelFormatter,
        shouldCenterLabel,
        secondaryItems: secondary.items,
        secondarySelectedIndex: secondary.selectedIndex,
        contextOptions: { ...options, locale: resolvedLocale },
        onParentClick: parentHandler,
        onChildrenClick: childrenHandler,
        pyramid: pyramidConfig,
        pyramidLayoutSpec: pyramidLayout,
        pyramidNormalized: adapterNormalized || normalized,
        pyramidAdapter: adapter,
        onSelectSecondary
      });
      if (options.dimensionEnabled && app?.setBlur) {
        app.setBlur(true);
      }
      renderDetail(app?.nav?.getCurrent?.(), adapter, manifest, adapterNormalized);
      app?.nav?.onChange?.(() => renderDetail(app?.nav?.getCurrent?.(), adapter, manifest, adapterNormalized));
      wireInteractions(app, items.length);
      showVersion();
    }).catch(err => {
      console.error('Failed to initialize app', err);
    });
  </script>
</body>
</html>
