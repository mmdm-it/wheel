<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Wheel v3 Demo</title>
  <link rel="preconnect" href="https://fonts.googleapis.com" />
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
  <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@500&family=EB+Garamond:wght@400;600&display=swap" rel="stylesheet" />
  <link rel="stylesheet" href="./styles/base.css" />
    <link id="volume-style" rel="stylesheet" href="" />
</head>
<body>
  <div id="version-badge" class="version-badge" aria-label="Application version"></div>
  <svg id="app" aria-label="Wheel v3"></svg>
  <script type="module">
    import { createApp, getViewportInfo, buildBibleVerseCousinChain, buildBibleBookCousinChain } from './src/index.js';

    const svg = document.getElementById('app');
    const viewport = getViewportInfo(window.innerWidth, window.innerHeight);

    async function loadConfig() {
      const params = new URLSearchParams(window.location.search);
      const path = (window.location.pathname || '').toLowerCase();
      const paramVolume = params.get('volume');
      const pathVolume = path.includes('/catalog')
        ? 'catalog'
        : path.includes('/calendar')
          ? 'calendar'
          : path.includes('/bible')
            ? 'bible'
            : null;
      const volume = ['catalog', 'calendar', 'bible'].includes(paramVolume)
        ? paramVolume
        : pathVolume || 'bible';

      const manifestPath = volume === 'catalog'
        ? './data/mmdm/mmdm_catalog.json'
        : volume === 'calendar'
          ? './data/calendar/manifest.json'
          : './data/gutenberg/manifest.json';

      console.info('[wheel-v3] volume selection', {
        pathname: path,
        paramVolume,
        pathVolume,
        resolvedVolume: volume,
        manifestPath
      });

      const manifest = await fetch(manifestPath).then(r => r.json());
      const volumeRoot = volume === 'catalog' ? manifest?.MMdM : volume === 'calendar' ? manifest?.Calendar : manifest?.Gutenberg_Bible;
      const startup = volumeRoot?.display_config?.focus_ring_startup || {};
      const arrangements = volumeRoot?.display_config?.focus_ring_arrangements || {};
      const level = params.get('level')
        || startup.top_navigation_level
        || (volume === 'bible' ? 'book' : volume === 'calendar' ? 'year' : 'manufacturer');
      const initialItemId = params.get('item') || startup.initial_magnified_item || null;
      const arrangement = params.get('arrangement')
        || arrangements[level]
        || startup.arrangement
        || (volume === 'bible' ? 'cousins-with-gaps' : volume === 'calendar' ? 'cousins-with-gaps' : 'cousins-flat');
      const cousinParam = params.get('cousins');
      const cousinMode = cousinParam === null
        ? arrangement !== 'siblings-only'
        : cousinParam === '1';
      return {
        volume,
        manifest,
        options: {
          level,
          initialItemId,
          arrangement,
          bookId: params.get('book') || 'GENE',
          testamentId: params.get('testament'),
          chapterId: params.get('chapter'),
          translation: params.get('translation') || 'NAB',
          cousinMode
        }
      };
    }

    function applyTheme(manifest, volume) {
      const root = document.documentElement;
      const theme = volume === 'catalog' ? 'catalog' : volume === 'calendar' ? 'calendar' : 'bible';
      root.setAttribute('data-theme', theme);
        const link = document.getElementById('volume-style');
        if (link) {
          link.setAttribute('href', `./styles/${theme}.css`);
        }
    }

    function buildBibleBooks(manifest) {
      const testaments = manifest?.Gutenberg_Bible?.testaments;
      if (!testaments) return [];
      const items = [];
      Object.entries(testaments).forEach(([testamentId, testament]) => {
        const sections = testament?.sections || {};
        Object.entries(sections).forEach(([sectionId, section]) => {
          const books = section?.books || {};
          Object.entries(books).forEach(([bookId, book]) => {
            items.push({
              id: bookId,
              name: book?.book_name || book?.name || bookId,
              sort: book?.sort_number || items.length + 1
            });
          });
        });
      });
      return items;
    }

    function buildCatalogManufacturers(manifest, { initialItemId } = {}) {
      const markets = manifest?.MMdM?.markets;
      if (!markets) return { items: [], selectedIndex: 0, preserveOrder: false };
      const items = [];
      const target = initialItemId ? String(initialItemId).toLowerCase() : null;
      Object.entries(markets).forEach(([marketId, market]) => {
        const countries = market?.countries || {};
        Object.entries(countries).forEach(([countryId, country]) => {
          const manufacturers = country?.manufacturers || {};
          Object.entries(manufacturers).forEach(([manufacturerId, manufacturer]) => {
            items.push({
              id: `${marketId}__${countryId}__${manufacturerId}`,
              name: manufacturerId,
              sort: Number.isFinite(manufacturer?.sort_number) ? manufacturer.sort_number : items.length + 1
            });
          });
        });
      });

      items.sort((a, b) => {
        const as = a.sort || 0;
        const bs = b.sort || 0;
        if (as === bs) return (a.name || '').localeCompare(b.name || '');
        return as - bs;
      });
      items.forEach((item, idx) => { item.order = idx; });

      const selectedIndex = (() => {
        if (target) {
          const idx = items.findIndex(item => {
            const simple = String(item.name || '').toLowerCase();
            return simple === target || String(item.id || '').toLowerCase() === target;
          });
          if (idx >= 0) return idx;
        }
        return 0;
      })();

      return { items, selectedIndex, preserveOrder: false };
    }

    function buildCalendarYears(manifest, { arrangement, initialItemId } = {}) {
      const years = manifest?.Calendar?.years;
      if (!years) return { items: [], selectedIndex: 0, preserveOrder: true };
      const sortedYears = Object.values(years)
        .map(year => {
          const yearNumber = Number.isFinite(year?.year_number) ? year.year_number : parseInt(year?.id, 10);
          const name = year?.name || (Number.isFinite(yearNumber) ? (yearNumber < 0 ? `${Math.abs(yearNumber)} BC` : `${yearNumber} AD`) : String(year?.id || ''));
          const sort = Number.isFinite(year?.sort_number) ? year.sort_number : yearNumber || 0;
          return {
            id: year?.id || String(yearNumber),
            name,
            sort,
            yearNumber
          };
        })
        .sort((a, b) => (a.sort || 0) - (b.sort || 0));

      const chain = [];
      let currentMillennium = null;
      sortedYears.forEach(year => {
        const millennium = year.yearNumber > 0
          ? Math.floor((year.yearNumber - 1) / 1000)
          : Math.floor((year.yearNumber) / 1000) - 1; // keep negative blocks distinct
        const shouldGap = (arrangement || 'cousins-with-gaps') === 'cousins-with-gaps';
        if (shouldGap && currentMillennium !== null && millennium !== currentMillennium) {
          chain.push(null, null); // 2-node gap between millennia
        }
        currentMillennium = millennium;
        chain.push({
          ...year,
          order: chain.length
        });
      });

      const selectedIndex = (() => {
        if (initialItemId !== undefined && initialItemId !== null) {
          const match = chain.findIndex(item => item && (item.id === String(initialItemId) || String(item.yearNumber) === String(initialItemId) || item.name === String(initialItemId)));
          if (match >= 0) return match;
        }
        const firstReal = chain.findIndex(item => item !== null);
        return firstReal >= 0 ? firstReal : 0;
      })();
      return {
        items: chain,
        selectedIndex,
        preserveOrder: true
      };
    }

    async function buildChain(manifest, volume, options = {}) {
      const arrangement = options.arrangement;
      const initialItemId = options.initialItemId;
      if (volume === 'bible' && options.cousinMode && (arrangement || 'cousins-with-gaps') !== 'siblings-only') {
        const level = options.level || 'book';
        if (level === 'verse') {
          return buildBibleVerseCousinChain(manifest, {
            bookId: options.bookId || 'GENE',
            startChapterId: options.chapterId || undefined,
            translation: options.translation || 'NAB'
          });
        }
        return buildBibleBookCousinChain(manifest, {
          testamentId: options.testamentId,
          bookId: options.bookId || 'GENE',
          initialItemId
        });
      }
      if (volume === 'catalog') {
        return buildCatalogManufacturers(manifest, { initialItemId });
      }
      if (volume === 'calendar') {
        return buildCalendarYears(manifest, { arrangement, initialItemId });
      }
      const items = buildBibleBooks(manifest)
        .sort((a, b) => {
          const as = a.sort || 0;
          const bs = b.sort || 0;
          if (as === bs) return (a.name || '').localeCompare(b.name || '');
          return as - bs;
        })
        .map((item, idx) => ({ ...item, order: idx }));
      const selectedIndex = (() => {
        if (initialItemId) {
          const idx = items.findIndex(item => item && (item.id === initialItemId));
          if (idx >= 0) return idx;
        }
        return 0;
      })();
      return { items, selectedIndex, preserveOrder: false };
    }

    function wireInteractions(app, itemCount) {
      let isDragging = false;
      let lastX = 0;
      let lastY = 0;
      let lastTime = 0;
      const sensitivity = Math.PI / 4 / 100; // 100px → 45°
      const velocityThreshold = 0.4; // px/ms below this → no gain
      const gainSlope = 1.1; // linear slope past threshold
      const baseQuickNodes = 60; // empirical baseline nodes per quick swipe at gain 1
      const targetSpinNodes = 350; // fixed quick-flick span for consistency across devices
      const baseMaxGain = Math.max(1, targetSpinNodes / baseQuickNodes);

      const onPointerMove = event => {
        if (!isDragging) return;
        const dx = event.clientX - lastX;
        const dy = event.clientY - lastY;
        const dt = event.timeStamp - lastTime;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;

        const distance = Math.abs(dx) + Math.abs(dy);
        const velocity = dt > 0 ? distance / dt : 0;
        const maxGain = baseMaxGain;
        const gain = velocity <= velocityThreshold
          ? 1
          : Math.min(maxGain, 1 + (velocity - velocityThreshold) * gainSlope);

        const delta = -(dx + dy) * sensitivity * gain;
        app.choreographer.rotate(delta);
      };

      svg.addEventListener('pointerdown', event => {
        const isNode = event.target && event.target.closest && event.target.closest('.focus-ring-node');
        if (isNode) {
          return; // click handler on node will manage rotation
        }
        isDragging = true;
        lastX = event.clientX;
        lastY = event.clientY;
        lastTime = event.timeStamp;
      });

      svg.addEventListener('pointermove', onPointerMove);

      ['pointerup', 'pointercancel', 'pointerleave'].forEach(type => {
        svg.addEventListener(type, () => {
          isDragging = false;
          app.selectNearest();
          app.choreographer.stopMomentum();
        });
      });
    }

    async function showVersion() {
      const badge = document.getElementById('version-badge');
      if (!badge) return;
      try {
        const pkg = await fetch('./package.json').then(r => r.json());
        const name = pkg?.name || 'wheel';
        const version = pkg?.version ? `v${pkg.version}` : 'v?';
        badge.textContent = `${name} ${version}`;
      } catch (err) {
        console.warn('Version load failed', err);
        badge.textContent = 'version unavailable';
      }
    }

    loadConfig().then(async ({ volume, manifest, options }) => {
      applyTheme(manifest, volume);
      const { items, selectedIndex = 0, preserveOrder = false } = await buildChain(manifest, volume, options);
      if (!items.length) {
        console.error('No items found for volume', volume);
        return;
      }
      const app = createApp({ svgRoot: svg, items, viewport, selectedIndex, preserveOrder });
      wireInteractions(app, items.length);
      showVersion();
    }).catch(err => {
      console.error('Failed to initialize app', err);
    });
  </script>
</body>
</html>
