<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MMdM Catalog</title>
    <link href="https://fonts.googleapis.com/css2?family=Montserrat:wght@400;700&display=swap" rel="stylesheet">
    <style>
        body { margin: 0; padding: 0; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f5e8c7; }
        svg { border: 1px solid #ccc; }
        .node { cursor: pointer; } /* No transition for instantaneous changes */
        .hidden { display: none; }
        text { font-size: 12px; font-family: 'Montserrat', sans-serif; text-transform: uppercase; }
    </style>
</head>
<body>
    <svg width="1000" height="1000" id="catalogSvg">
        <g id="mainGroup" transform="translate(500, 350)">
            <!-- Central Node (MMdM) -->
            <circle class="node" cx="0" cy="0" r="25" fill="gray" id="mmdmNode" />
            <text x="0" y="0" text-anchor="middle" dy="0.3em" fill="black">MMdM</text>

            <!-- Country Ring -->
            <g id="countries"></g>

            <!-- Manufacturer Ring (Hidden initially) -->
            <g id="manufacturers" class="hidden"></g>

            <!-- Cylinders Ring (Hidden initially) -->
            <g id="cylinders" class="hidden"></g>

            <!-- Models Ring (Hidden initially) -->
            <g id="models" class="hidden"></g>

            <!-- Manifolds Ring (Hidden initially) -->
            <g id="manifolds" class="hidden"></g>
        </g>
    </svg>
    <script>
        const svg = document.getElementById('catalogSvg');
        const mainGroup = document.getElementById('mainGroup');
        const countriesGroup = document.getElementById('countries');
        const manufacturersGroup = document.getElementById('manufacturers');
        const cylindersGroup = document.getElementById('cylinders');
        const modelsGroup = document.getElementById('models');
        const manifoldsGroup = document.getElementById('manifolds');
        let activeNode = null;
        let activeType = null;
        let activePath = []; // Track the active path (e.g., ['USA', 'Caterpillar', '6'])
        let data = null;
        const isMobile = /Mobi|Android/i.test(navigator.userAgent);
        const modelAngles = {}; // Store initial model angles globally
        const cylinderAngles = {}; // Store initial cylinder angles for consistent model rendering

        // Load JSON data
        async function loadData() {
            try {
                const response = await fetch('./catalog.json');
                data = await response.json();
                console.log('Loaded data:', JSON.stringify(data, null, 2));
                renderCountries();
            } catch (error) {
                console.error('Error loading catalog.json:', error);
                alert('Failed to load catalog data. Please check the file path.');
            }
        }

        // Render country nodes (75px ring)
        function renderCountries(selectedCountry = null) {
            console.log('Rendering countries, selected:', selectedCountry);
            countriesGroup.innerHTML = '';
            const countries = Object.keys(data.MMdM.countries);
            countries.forEach((country, index) => {
                const isSelected = country === selectedCountry && activeType === 'country';
                const radius = 75; // Fixed 75px for position
                const angle = (index / countries.length) * 2 * Math.PI;
                const r = isSelected ? 30 : 15;
                const offset = r + 5;
                const textX = offset * Math.cos(angle);
                const textY = offset * Math.sin(angle);
                let rotation = angle * 180 / Math.PI;
                let textAnchor = Math.cos(angle) >= 0 ? 'start' : 'end';
                let dy = '0.3em';
                if (Math.cos(angle) < 0) {
                    rotation += 180;
                    dy = '-0.3em';
                }
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const g = document.createElementNS("http://www.w3.org/2000/svg", 'g');
                g.classList.add('country');
                g.setAttribute('transform', `translate(${x}, ${y})`);
                g.innerHTML = `
                    <circle class="node" cx="0" cy="0" r="${r}" fill="${getColor('country', country)}" />
                    <text x="${textX}" y="${textY}" dy="${dy}" text-anchor="${textAnchor}" transform="rotate(${rotation}, ${textX}, ${textY})" fill="black">${country}</text>
                `;
                countriesGroup.appendChild(g);
                addNodeListeners(g, 'country', country, angle, isSelected);
            });
        }

        // Render manufacturer nodes (375px ring)
        function renderManufacturers(country, countryAngle, selectedManufacturer = null) {
            console.log('Rendering manufacturers for', country, 'selected:', selectedManufacturer);
            manufacturersGroup.innerHTML = '';
            const manufacturers = Object.keys(data.MMdM.countries[country].manufacturers);
            const angleSpread = manufacturers.length > 1 ? Math.PI / 24 : 0; // 7.5° spread for multiple nodes
            manufacturers.forEach((manufacturer, index) => {
                const isSelected = manufacturer === selectedManufacturer && activeType === 'manufacturer';
                const radius = 375; // Fixed 375px for position
                const centerAngle = Math.PI / 2;
                const angle = centerAngle + (index - (manufacturers.length - 1) / 2) * angleSpread;
                const r = isSelected ? 30 : 12;
                const offset = - (r + 5);
                const textX = offset * Math.cos(angle);
                const textY = offset * Math.sin(angle);
                let rotation = angle * 180 / Math.PI;
                let textAnchor = Math.cos(angle) >= 0 ? 'start' : 'end';
                let dy = '0.3em';
                if (Math.cos(angle) < 0) {
                    rotation += 180;
                    dy = '-0.3em';
                }
                const g = document.createElementNS("http://www.w3.org/2000/svg", 'g');
                g.classList.add('manufacturer');
                g.setAttribute('transform', `translate(${radius * Math.cos(angle)}, ${radius * Math.sin(angle)})`);
                g.innerHTML = `
                    <circle class="node" cx="0" cy="0" r="${r}" fill="${getColor('manufacturer', manufacturer)}" />
                    <text x="${textX}" y="${textY}" dy="${dy}" text-anchor="${textAnchor}" transform="rotate(${rotation}, ${textX}, ${textY})" fill="black">${manufacturer}</text>
                `;
                manufacturersGroup.appendChild(g);
                addNodeListeners(g, 'manufacturer', `${country}/${manufacturer}`, angle, isSelected);
            });
        }

        // Render cylinder nodes (300px ring)
        function renderCylinders(country, manufacturer, manufacturerAngle, selectedCylinder = null) {
            console.log('Rendering cylinders for', country, manufacturer, 'selected:', selectedCylinder);
            cylindersGroup.innerHTML = '';
            const cylinders = data.MMdM.countries[country].manufacturers[manufacturer]?.cylinders;
            if (!cylinders) {
                console.error(`No cylinders found for ${manufacturer} in ${country}`);
                return;
            }
            const cylinderKeys = Object.keys(cylinders);
            const angleSpread = cylinderKeys.length > 1 ? Math.PI / 12 : 0; // 15° spread for multiple nodes
            cylinderKeys.forEach((cylinder, index) => {
                const isSelected = cylinder === selectedCylinder && activeType === 'cylinder';
                const radius = 300; // Fixed 300px for position
                const angle = manufacturerAngle + (index - (cylinderKeys.length - 1) / 2) * angleSpread;
                const r = isSelected ? 30 : 10;
                const offset = r + 5;
                const textX = offset * Math.cos(angle);
                const textY = offset * Math.sin(angle);
                let rotation = angle * 180 / Math.PI;
                let textAnchor = Math.cos(angle) >= 0 ? 'start' : 'end';
                let dy = '0.3em';
                if (Math.cos(angle) < 0) {
                    rotation += 180;
                    dy = '-0.3em';
                }
                const cylinderKey = `${country}/${manufacturer}/${cylinder}`;
                if (cylinderAngles[cylinderKey] === undefined) {
                    cylinderAngles[cylinderKey] = angle; // Store initial cylinder angle
                }
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const g = document.createElementNS("http://www.w3.org/2000/svg", 'g');
                g.classList.add('cylinder');
                g.setAttribute('transform', `translate(${x}, ${y})`);
                g.innerHTML = `
                    <circle class="node" cx="0" cy="0" r="${r}" fill="${getColor('cylinder', cylinder)}" />
                    <text x="${textX}" y="${textY}" dy="${dy}" text-anchor="${textAnchor}" transform="rotate(${rotation}, ${textX}, ${textY})" fill="black">${cylinder}</text>
                `;
                cylindersGroup.appendChild(g);
                addNodeListeners(g, 'cylinder', cylinderKey, angle, isSelected);
            });
        }

        // Render model nodes (225px ring)
        function renderModels(country, manufacturer, cylinder, cylinderAngle, selectedModel = null) {
            console.log('Rendering models for', country, manufacturer, cylinder, 'selected:', selectedModel);
            modelsGroup.innerHTML = '';
            const models = data.MMdM.countries[country].manufacturers[manufacturer].cylinders[cylinder];
            if (!models) {
                console.error(`No models found for ${cylinder} in ${manufacturer}, ${country}`);
                return;
            }
            const angleSpread = models.length > 1 ? Math.PI / 12 : 0; // 15° spread for multiple nodes
            models.forEach((model, index) => {
                const isSelected = model.model === selectedModel && activeType === 'model';
                const radius = 225; // Fixed 225px for position
                const modelKey = `${country}/${manufacturer}/${cylinder}/${model.model}`;
                // Use stored angle if available, otherwise calculate and store
                let angle;
                if (modelAngles[modelKey] !== undefined) {
                    angle = modelAngles[modelKey];
                } else {
                    angle = cylinderAngle + (index - (models.length - 1) / 2) * angleSpread;
                    modelAngles[modelKey] = angle; // Store initial angle
                }
                const r = isSelected ? 30 : 8;
                const offset = r + 5;
                const textX = offset * Math.cos(angle);
                const textY = offset * Math.sin(angle);
                let rotation = angle * 180 / Math.PI;
                let textAnchor = Math.cos(angle) >= 0 ? 'start' : 'end';
                let dy = '0.3em';
                if (Math.cos(angle) < 0) {
                    rotation += 180;
                    dy = '-0.3em';
                }
                const x = radius * Math.cos(angle);
                const y = radius * Math.sin(angle);
                const g = document.createElementNS("http://www.w3.org/2000/svg", 'g');
                g.classList.add('model');
                g.setAttribute('transform', `translate(${x}, ${y})`);
                g.setAttribute('data-model', model.model);
                g.innerHTML = `
                    <circle class="node" cx="0" cy="0" r="${r}" fill="${getColor('model', model.model)}" />
                    <text x="${textX}" y="${textY}" dy="${dy}" text-anchor="${textAnchor}" transform="rotate(${rotation}, ${textX}, ${textY})" fill="black">${model.model}</text>
                `;
                modelsGroup.appendChild(g);
                addNodeListeners(g, 'model', modelKey, angle, isSelected);
            });
        }

        // Render manifold nodes (150px ring)
        function renderManifolds(country, manufacturer, cylinder, model, modelAngle) {
            console.log('Rendering manifold for', country, manufacturer, cylinder, model, 'angle:', modelAngle);
            manifoldsGroup.innerHTML = '';
            const models = data.MMdM.countries[country].manufacturers[manufacturer].cylinders[cylinder];
            const manifold = models.find(m => m.model === model)?.manifold;
            if (!manifold) {
                console.error(`No manifold found for ${model} in ${cylinder}, ${manufacturer}, ${country}`);
                return;
            }
            const radius = 150; // Fixed 150px for position
            const angle = modelAngle; // Align with parent model
            const r = 6;
            const offset = r + 5;
            const textX = offset * Math.cos(angle);
            const textY = offset * Math.sin(angle);
            let rotation = angle * 180 / Math.PI;
            let textAnchor = Math.cos(angle) >= 0 ? 'start' : 'end';
            let dy = '0.3em';
            if (Math.cos(angle) < 0) {
                rotation += 180;
                dy = '-0.3em';
            }
            const x = radius * Math.cos(angle);
            const y = radius * Math.sin(angle);
            const g = document.createElementNS("http://www.w3.org/2000/svg", 'g');
            g.classList.add('manifold');
            g.setAttribute('transform', `translate(${x}, ${y})`);
            g.innerHTML = `
                <circle class="node" cx="0" cy="0" r="${r}" fill="${getColor('manifold', manifold)}" />
                <text x="${textX}" y="${textY}" dy="${dy}" text-anchor="${textAnchor}" transform="rotate(${rotation}, ${textX}, ${textY})" fill="black">${manifold}</text>
            `;
            manifoldsGroup.appendChild(g);
        }

        // Add event listeners to nodes
        function addNodeListeners(node, type, name, angle, isSelected) {
            const eventType = isMobile ? 'click' : 'mouseover';
            node.addEventListener(eventType, () => {
                if (activeNode === node && activeType === type && isSelected) {
                    console.log(`Node ${type}: ${name} already active, skipping`);
                    return;
                }
                console.log(`Activating ${type}: ${name} at angle ${angle}`);
                activeNode = node;
                activeType = type;
                activePath = name.split('/'); // Update active path
                resetView(false, type, name);
                renderNextLevel(type, name, angle);
            });
        }

        // Render next level based on current node
        function renderNextLevel(type, name, angle) {
            console.log(`Rendering next level for ${type}: ${name}`);
            const country = name.split('/')[0];
            const countryAngle = getCountryAngle(country);
            if (type === 'country') {
                manufacturersGroup.classList.remove('hidden');
                console.log('Showing manufacturers group');
                renderCountries(activePath[0]);
                renderManufacturers(name, countryAngle);
            } else if (type === 'manufacturer') {
                cylindersGroup.classList.remove('hidden');
                console.log('Showing cylinders group');
                renderCountries(activePath[0]);
                renderManufacturers(name.split('/')[0], countryAngle, activePath[1]);
                renderCylinders(name.split('/')[0], name.split('/')[1], angle);
            } else if (type === 'cylinder') {
                modelsGroup.classList.remove('hidden');
                console.log('Showing models group');
                renderCountries(activePath[0]);
                const manufacturer = name.split('/')[1];
                const manufacturerAngle = getManufacturerAngle(activePath[0], manufacturer, countryAngle);
                renderManufacturers(name.split('/')[0], countryAngle, activePath[1]);
                renderCylinders(name.split('/')[0], name.split('/')[1], manufacturerAngle, activePath[2]);
                // Use stored cylinder angle for consistency
                const cylinderKey = name;
                const storedCylinderAngle = cylinderAngles[cylinderKey] || angle;
                renderModels(name.split('/')[0], name.split('/')[1], name.split('/')[2], storedCylinderAngle, activePath[3]);
            } else if (type === 'model') {
                manifoldsGroup.classList.remove('hidden');
                console.log('Showing manifolds group');
                renderCountries(activePath[0]);
                renderManufacturers(name.split('/')[0], countryAngle, activePath[1]);
                const cylinderKey = `${name.split('/')[0]}/${name.split('/')[1]}/${name.split('/')[2]}`;
                const storedCylinderAngle = cylinderAngles[cylinderKey] || getCylinderAngle(name.split('/')[0], name.split('/')[1], name.split('/')[2], getManufacturerAngle(name.split('/')[0], name.split('/')[1], countryAngle));
                renderCylinders(name.split('/')[0], name.split('/')[1], getManufacturerAngle(name.split('/')[0], name.split('/')[1], countryAngle), activePath[2]);
                // Use stored model angle
                const modelKey = name;
                const modelAngle = modelAngles[modelKey] || angle;
                renderModels(name.split('/')[0], name.split('/')[1], name.split('/')[2], storedCylinderAngle, activePath[3]);
                renderManifolds(name.split('/')[0], name.split('/')[1], name.split('/')[2], name.split('/')[3], modelAngle);
            }
        }

        // Helper functions to calculate angles
        function getCountryAngle(country) {
            const countries = Object.keys(data.MMdM.countries);
            const index = countries.indexOf(country);
            return (index / countries.length) * 2 * Math.PI;
        }

        function getManufacturerAngle(country, manufacturer, countryAngle) {
            const manufacturers = Object.keys(data.MMdM.countries[country].manufacturers);
            const index = manufacturers.indexOf(manufacturer);
            const angleSpread = manufacturers.length > 1 ? Math.PI / 24 : 0;
            const centerAngle = Math.PI / 2;
            return centerAngle + (index - (manufacturers.length - 1) / 2) * angleSpread;
        }

        function getCylinderAngle(country, manufacturer, cylinder, manufacturerAngle) {
            const cylinders = Object.keys(data.MMdM.countries[country].manufacturers[manufacturer].cylinders);
            const index = cylinders.indexOf(cylinder);
            const angleSpread = cylinders.length > 1 ? Math.PI / 12 : 0;
            return manufacturerAngle + (index - (cylinders.length - 1) / 2) * angleSpread;
        }

        // Reset view to MMdM
        function resetView(clearActive = true, nextType = null, nextName = null) {
            console.log('Resetting view, clearActive:', clearActive, 'nextType:', nextType, 'nextName:', nextName);
            mainGroup.setAttribute('transform', 'translate(500, 350)');
            countriesGroup.innerHTML = '';
            manufacturersGroup.innerHTML = '';
            cylindersGroup.innerHTML = '';
            modelsGroup.innerHTML = '';
            manifoldsGroup.innerHTML = '';
            manufacturersGroup.classList.add('hidden');
            cylindersGroup.classList.add('hidden');
            modelsGroup.classList.add('hidden');
            manifoldsGroup.classList.add('hidden');
            if (clearActive) {
                activeNode = null;
                activeType = null;
                activePath = [];
            }
            if (nextType === 'country') {
                renderCountries(nextName);
            } else if (nextType === 'manufacturer') {
                const country = nextName.split('/')[0];
                const selectedManufacturer = nextName.split('/')[1];
                const countryAngle = getCountryAngle(country);
                renderCountries(country);
                manufacturersGroup.classList.remove('hidden');
                renderManufacturers(country, countryAngle, selectedManufacturer);
            } else if (nextType === 'cylinder') {
                const country = nextName.split('/')[0];
                const manufacturer = nextName.split('/')[1];
                const selectedCylinder = nextName.split('/')[2];
                const countryAngle = getCountryAngle(country);
                const manufacturerAngle = getManufacturerAngle(country, manufacturer, countryAngle);
                renderCountries(country);
                manufacturersGroup.classList.remove('hidden');
                renderManufacturers(country, countryAngle, manufacturer);
                cylindersGroup.classList.remove('hidden');
                renderCylinders(country, manufacturer, manufacturerAngle, selectedCylinder);
            } else if (nextType === 'model') {
                const country = nextName.split('/')[0];
                const manufacturer = nextName.split('/')[1];
                const cylinder = nextName.split('/')[2];
                const selectedModel = nextName.split('/')[3];
                const countryAngle = getCountryAngle(country);
                const manufacturerAngle = getManufacturerAngle(country, manufacturer, countryAngle);
                const cylinderKey = `${country}/${manufacturer}/${cylinder}`;
                const cylinderAngle = cylinderAngles[cylinderKey] || getCylinderAngle(country, manufacturer, cylinder, manufacturerAngle);
                renderCountries(country);
                manufacturersGroup.classList.remove('hidden');
                renderManufacturers(country, countryAngle, manufacturer);
                cylindersGroup.classList.remove('hidden');
                renderCylinders(country, manufacturer, manufacturerAngle, cylinder);
                modelsGroup.classList.remove('hidden');
                renderModels(country, manufacturer, cylinder, cylinderAngle, selectedModel);
            }
        }

        // Color function for hierarchy levels
        function getColor(type, name) {
            return 'lightgray';
        }

        // Add reset on MMdM click
        document.getElementById('mmdmNode').addEventListener('click', () => {
            console.log('Resetting to MMdM view');
            resetView(true);
            renderCountries();
        });

        // Handle mouseout (desktop only) with delay
        if (!isMobile) {
            let timeout;
            svg.addEventListener('mouseout', (e) => {
                if (!svg.contains(e.relatedTarget)) {
                    console.log('Mouseout triggered');
                    clearTimeout(timeout);
                    timeout = setTimeout(() => {
                        console.log('Mouseout reset executed');
                        resetView(true);
                        renderCountries();
                    }, 300);
                }
            });
            svg.addEventListener('mouseover', () => {
                console.log('Mouseover SVG, clearing timeout');
                clearTimeout(timeout);
            });
        }

        // Initialize
        console.log('Initializing visualization');
        loadData();
    </script>
</body>
</html>